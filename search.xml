<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试自我介绍样例]]></title>
    <url>%2Fmoblog.github.io%2Fcv%2Fsecurity%2F</url>
    <content type="text"><![CDATA[如何进行自我介绍 面试过程中，我们难免会遇到，面试官让你自我介绍，如何给面试官留下好的印象呢 面试问题第一问，95%都会是： 请简单的做个自我介绍吧~ 分以下几点说明。 一、个人的基本信息，扬长避短 1、年纪太大与太小，都不需要主动去说明。 比如我年纪只有21岁 例子：面试官您好，我叫***，来自于哪里，从事软件测试工作有几年了。 2、专业不对口也不要过多的去提及（提到了就会增加问你的概率）。 比如你的专业是机械专业 例子：面试官您好，我叫***，来自于哪里，从事软件测试工作有几年了。 比如你的专业是计算机专业 例子：面试官您好，我叫***，来自于哪里，计算机专业毕业后，从事软件测试工作有几年了。 二、突出自己的工作经验自己的项目经验（重点突出跟你面试公司相关或者同类型的项目）。 比如公司从事的主要是web项目： 以前主要是从事web系统的项目，做过不少的项目，也积累了不少的测试经验，能够独立完成产品的测试。 比如公司从事的主要是app项目： 以前主要是从事的web与app的项目，最近做的项目主要是app为主，做过不少的项目，也积累了不少的测试经验，能够独立完成产品的测试。 三、突出自己的技能 1、测试流程 2、测试需求分析 3、linux系统 4、数据库 5、接口测试 6、性能测试 7、自动化测试 8、安全测试 9、语言 基于目前市场情况，基本前面5个必备，市场的竞争会越来越大，后期大家需要好好的学习。 四、个人兴趣爱好与结尾简单说下就ok。 例子：我平常喜欢看看书，有的时候也喜欢打打游戏，这个是我一个简单的自我介绍，您看，我这边还需要做什么补充吗？ 总体案例： 面试官您好，我叫xxx，来自于xxx。做软件测试工作有三年了。在期间做了不少的项目，也积累了不少的测试经验，能够独立完成软件测试的测试工作，主要做过功能测试、app专项测试和接口测试方面的工作。对于linux、数据库、fiddler、jmeter的应用都比较熟悉。也用jmeter做过一些性能测试，最近一段时间也做了自动化测试，主要是用的python+selenium框架实现的，我平常喜欢看看书，有的时候也喜欢打打游戏，这个是我一个简单的自我介绍，您看，我这边还需要做什么补充吗？ 最后一点：对于自己“会”的重点强调，如果性能跟自动化不会就说只是了解一些，根据自己的情况来定，切记不要照搬。 给大家一个参考，希望有用。 面试官您好，我叫赵文消，来自于云南文山。做j2ee工作有四年了。在期间做过大大小小的各类项目:OA,ERP,电商网站后台,小程序后端服务。项目过程中的技术选型主要来自开源web框架并在此基础上进行改进和完善,比如jeecg,jfinal;从这些框架中学到了很多的设计思想、编码技巧、代码质量、各种异常处理、设计模式。在有的项目中也尝试过使用nodejs框架，微服务架构springcloud，使用过程中遇到的问题很多，也成长了很多，积累了不少的项目经验。目前自己对于整个软件开发流程;从需求，设计，编码，测试，部署，运维各个阶段都有比较清晰的思路。掌握的编码技能呢，以后端技能为主:java、spring、springboot、hiberbate、mybatis。页面模板:jsp、Velocity、freemark、thymeleaf（钛立父）等等，对于linux、数据库都比较熟悉。近一两年的工作当中更多的是，扮演一个协调者和沟通者的角色，特别强调项目组成员应该高效的协作，降低代码之间的耦合度，而不是单打独斗，从代码风格，代码规范上都要求比较严格。业余时间喜欢写一些技术博客，运营一下自己的小程序和公众号,再者就是打打篮球，锻炼一下身体，以上就是一个简单的自我介绍，您看，我这边还需要做什么补充吗？]]></content>
      <categories>
        <category>简历</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud开源示例项目推荐：优秀资源、使用实例一应俱全]]></title>
    <url>%2Fmoblog.github.io%2Fspringcloud%2Fspringcloud%2F</url>
    <content type="text"><![CDATA[Spring Cloud Examples Spring Cloud 使用的各种示例，以最简单、最实用为标准Spring Cloud 中文索引 &nbsp;| &nbsp; Spring Boot学习示例代码 &nbsp;| &nbsp; 参与贡献 English &nbsp;| &nbsp; github地址 &nbsp;| &nbsp; 码云地址 Spring Cloud 使用的各种示例，以最简单、最实用为标准 Spring Boot 2.0 最全使用教程 spring-cloud-eureka：eureka server单机、双机、集群示例 eureka-producer-consumer：利用eureka实现服务提供与调用示例 spring-cloud-hystrix：Hystrix熔断的使用示例 hystrix-dashboard-turbine：熔断监控Hystrix Dashboard和Turbine的示例 spring-cloud-config-git：配置中心git版本示例 spring-cloud-config-svn-refresh：配置中心svn版本示例，客户端refresh版本示例 spring-cloud-config-eureka：配置中心服务化和高可用代码示例 spring-cloud-config-eureka-bus：配置中心和消息总线示例（配置中心终结版） gateway-service-zuul：Spring Cloud Zuul使用初级篇 网关 均衡负载 spring-cloud-zuul：Spring Cloud Zuul使用高级篇 Filter 鉴权 熔断 重试 spring-cloud-sleuth-zipkin： 利用Sleuth、Zipkin对Spring Cloud应用进行服务追踪分析 spring-boot-admin-eureka： 使用Spring Boot Admin 对Spring Cloud集群进行监控示例 spring-cloud-consul： Spring Cloud 使用 Consul 作为服务中心示例 spring-cloud-gateway： Spring Cloud 使用 gateway 的相关示例 学习系列： springcloud(一)：大话Spring Cloud springcloud(二)：注册中心Eureka springcloud(三)：服务提供与调用 springcloud(四)：熔断器Hystrix springcloud(五)：熔断监控Hystrix Dashboard和Turbine springcloud(六)：配置中心git示例 springcloud(七)：配置中心svn示例和refresh springcloud(八)：配置中心服务化和高可用 springcloud(九)：配置中心和消息总线（配置中心终结版） springcloud(十)：服务网关zuul springcloud(十一)：服务网关Zuul高级篇 springcloud(十二)：使用Spring Cloud Sleuth和Zipkin进行分布式链路跟踪 springcloud(十三)：Spring Cloud Consul 使用详解 Spring Cloud (十四)：Spring Cloud 开源软件都有哪些？ springcloud(十五)：服务网关 Spring Cloud GateWay 初级篇 springcloud(十六)：服务网关 Spring Cloud GateWay 服务化和过滤器 springcloud(十七)：服务网关 Spring Cloud GateWay 熔断、限流、重试 综合篇： Spring Cloud在国内中小型公司能用起来吗？ 中小型互联网公司微服务实践-经验和教训 从架构演进的角度聊聊Spring Cloud都做了些什么？ 阿里Dubbo疯狂更新，关Spring Cloud什么事？ 如果大家想了解关于springcloud的其它方面应用，也可以以issues的形式反馈给我，我后续来完善。 关注公众号：纯洁的微笑，回复”springboot”进群交流]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务专题]]></title>
    <url>%2Fmoblog.github.io%2FMicroService%2FMicroService%2F</url>
    <content type="text"><![CDATA[#引言 恕我直言，你可能误解了微服务 随着云计算和容器技术的普及，互联网 IT 基础设施已经发生了很大的变革，也推动了微服务技术的大量采用和落地。现在的技术人，不谈微服务已经要跟不上形势了。但是你真的对微服务有正确的理解吗？要向微服务转型，有哪些问题和挑战摆在面前？如何拨开现代各种技术栈的迷雾看清微服务的发展趋势，选择最适合团队的技术方向？本次 InfoQ 记者采访了网易杭州研究院云计算技术部的首席架构师刘超，为大家分享他对这些问题的看法。刘超也是今年 5 月份 QCon 全球软件开发大会广州站「微服务实战」专题的出品人，将为大家策划几场微服务相关的内容丰富的分享。 InfoQ：刘超老师，请先介绍一下自己吧。刘超：我是网易云的首席架构师，主要负责两部分工作，对内支撑网易核心业务上云，例如考拉，云音乐，云课堂，对外输出网易的微服务经验，帮助客户搞定容器化与微服务化架构，已经在银行、证券、物流、视频监控、智能制造等多个行业落地。 InfoQ：网易云在微服务方面的探索有哪些？落地过程中有哪些难点？刘超：网易云的技术团队在博客时代就开始探索互联网架构，是在支撑博客用户量、访问量就爆发式增长的过程中，构建了聚焦微服务的网易云轻舟平台，并支撑内部考拉、云音乐、云课堂等核心业务。 在实施微服务的过程中，难点层出不穷，可谓见山开路，遇水搭桥。 实施服务化架构之后，首先实现的功能是进行统一的注册发现和 RPC 的透明封装，但是服务拆分多了，在应用层面就遇到以下问题： 服务雪崩：即一个服务挂了，整个调用链路上的所有的服务都会受到影响；大量请求堆积、故障恢复慢：即一个服务慢，卡住了，整个调用链路出现大量超时，要长时间等待慢的服务恢复到正常状态。在基础设施层面，还有另外的问题： 服务器资源分配困难，服务器机型碎片化：服务多了，各个团队都要申请服务器，规格不一，要求多样，管理十分困难；一台服务器上多个进程互相影响、QoS 难以保障：采用虚拟机或者物理机的部署，往往会多个进程放在一台服务器上，高峰期影响严重；测试环境数量大增，环境管理、部署更新困难：每个团队都有反复部署测试环境，手动部署或者脚本部署过于复杂。为了解决这些问题，我们在应用层面实施了以下方案： 通过熔断机制，当一个服务挂了，被影响的服务能够及时熔断，使用 Fallback 数据保证流程在非关键服务不可用的情况下，仍然可以进行。通过线程池和消息队列机制实现异步化，允许服务快速失败，当一个服务因为过慢而阻塞，被影响服务可以在超时后快速失败，不会影响整个调用链路。在基础设施层面，我们实施了以下的方案： 统一基础设施，拥抱容器标准，解决服务器碎片化和服务之间的隔离问题；统一编排和弹性伸缩平台，2015 年拥抱 Kubernetes 标准，解决了部署困难，环境不一致的问题；打造 CI/CD 服务，抽象出产品、环境等多级概念，实现从代码到测试到上线的自动部署。随着我们支撑的内部业务越来越多，就进一步遇到了以下问题： 微服务框架选型不一，技术无法积累，面向业务定制化严重，上手成本高；传统依赖于应用运维的排障复杂度高，传统监控服务无法满足需求；故障演练手段不一，硬编码随处可见；API 版本管理混乱，无统一的监控，治理，无开发标准；分布式事务支持方式不一，和业务绑定严重。为了解决这些问题，我们实施了以下方案： 微服务框架与开源技术栈统一，将服务治理逻辑抽离、以无侵入方式实现、支持 Spring Cloud、Dubbo 等开源技术栈；全链路跟踪服务与日志服务依据 ID 进行联系，以发现故障点上下文；在 Agent 引入故障注入服务，可统一进行故障演练；服务通过 API 网关暴露，引入 API 管理、测试平台，自动 Client SDK 生成；实现 TCC 中间件、事务消息队列等标准中间件。InfoQ：你如何理解微服务？微服务在当前技术形势下处于一个什么样的位置？刘超：微服务是一个非常复杂的问题，在业内会有一些误解： 微服务主要的工作是服务拆分，主要考虑将服务拆分成什么粒度以及如何进行拆分； 微服务是一个运动式的过程，把大家关起门来封闭开发一个月，就能把架构修改好了，以后就万事大吉了； 微服务仅仅是一个技术问题，交给开发团队或者运维团队去搞就可以了。微服务绝不仅仅是服务拆分，就像上图所示，拆分只是实施微服务十二个要点之一，因为拆分了服务之后，会面临上面我们遇到的所有问题，没有相应的工具和平台，拆分的越细，越是一场灾难。 微服务绝不是一个运动式的过程，而是应该渐进的过程，一旦实施了微服务，就处于业务系统不断更新和迭代的状态中，也处于不断的拆分和组合中。所以不建议一开始就拆的特别细，不建议一劳永逸，而是随着慢慢的拆成几个，十几个，几十个，上百个的过程，将十二个要点所需要的工具、团队、员工能力慢慢匹配到微服务状态。 微服务绝不仅仅是个技术问题，牵扯到 IT 架构、应用架构、组织架构多个方面。微服务必定带来开发、上线、运维的复杂度的提高，如果说单体应用复杂度为 10，实施了微服务后的复杂度将是 100，配备了相应的工具和平台后，可以将复杂度降低到 50，但仍然比单体复杂的多。 所以实施微服务是有成本的，只有在业务层面遇到不微不行的痛点，例如痛到影响收入，痛到被竞争对手甩在后面，所以微服务往往是业务驱动或者高管驱动的，而实施微服务的结果又必然会影响到组织架构的变化，例如运维和开发的界限模糊——DevOps，专门中间件和架构师团队的成立，数据中台和业务中台组的建立，小团队自主决策等。 目前，大多数企业都意识到了微服务的重要性，但是各处的阶段不同，我把微服务分成三个阶段： 微服务 1.0，仅使用注册发现，基于 SpringCloud 或者 Dubbo 进行开发，目前意图实施微服务的传统企业大部分处于这个阶段，或者正从单体应用，向这个阶段过渡，处于 0.5 的阶段；微服务 2.0，使用了熔断，限流，降级等服务治理策略，并配备完整微服务工具和平台，目前大部分互联网企业处于这个阶段。传统企业中的领头羊，在做互联网转型的过程中，正在向这个阶段过渡，处于 1.5 的阶段；微服务 3.0，Service Mesh 将服务治理作为通用组件，下沉到平台层实现，使得应用层仅仅关注业务逻辑，平台层可以根据业务监控自动调度和参数调整，实现 AIOps 和智能调度。目前一线互联网公司在进行这方面的尝试。InfoQ：你怎么看微服务未来的发展趋势？刘超：前面大概谈了一下微服务 3.0，这里详细说一下我眼中的微服务的发展趋势。 第一个就是 Service Mesh，他的主要作用就是将服务治理下沉到平台层，进行统一的治理。 为什么会这样呢？因为无论是在我们内部，还是在外部企业，都能看的这样的趋势。 最初只有物理机，虚拟机是放在云平台上，由运维组统一管理的。 后来因为能力复用和开发速度的需要，数据库、中间件成为了 PaaS 平台用于部署通用的组件，持续发布也成了 PaaS 平台，用于部署客户的业务，所以这两部分也平台化了。 随着越来越多的业务需要进行服务治理，微服务框架，APM，也成为了平台的一部分。 但是微服务框架的统一，涉及多语言的问题，也涉及和应用层绑定的问题，无论是 Spring Cloud 还是 Dubbo，都很难完全平台化，所以需要 Service Mesh，通过 sidecar 的方式，将控制面和数据面隔离，通过非侵入的模式进行流量拦截，实现真正的治理平台化。 第二个就是 AIOps 和智能调度，就是通过对于海量数据中心收集的监控数据和业务数据，实现业务的自动调度和参数调整。 这个看起来很遥远，其实不然，如果大家感兴趣的话，可以在网上搜索一下，Google 在 2011 年就公布了自己数据中心收集的监控数据（https://github.com/google/cluster-data/blob/master/ClusterData2011_2.md），并在 2014 年发表论文《Machine Learning Applications for Data Center Optimization》，使用 AI 技术优化数据中心的效率。 而国内一线互联网公司也在 2018 年公布 4000 台服务器真实数据集，也在干和 Google 类似的事情。 我们观察到，当数据中心的机器规模突破十万台的时候，效率的提高就变成了一件能够节省大量成本的事情，所以开始引起重视。而能做到这件事情，往往依靠的就是数据驱动的智能调度。 为了支撑强大的调度功能，Google 开发了 Borg，Twitter 壮大了 Mesos，并通过将这些调度平台和机器学习相结合，实现自动化的智能调度，国内一线互联网公司也在进行着积极的尝试。 随着微服务化和容器化，服务的数量会十分的庞大，从而运维难度大幅度提高，原来仅仅会运维物理机和虚拟化的技术人员是不够的，而运维 Kubernetes 和 Docker 的人会比较贵，使得人力成本大幅度提高。 很多组织从物理机时代，到虚拟化时代，到云时代，再到容器时代，运维团队的规模是越来越大的，每个人的薪资也越来越高。 所以将来只运维少量节点的私有化容器平台，势必从成本上来讲是不划算的，当出现有公信力的公有云平台，则势必使用公有云成为节约成本的理智选择。 例如亚马逊、谷歌等公有云平台就没有问题，谷歌里面的运维工程师相当贵，他们掌握最先进的技术是没有任何问题的，但是他们会通过各种自动化，甚至智能化的技术，管理全球的几百万台机器，这样成本摊下来就不是很高了。如果你只是运维一个几十个节点，最多几百个节点的容器平台，同样需要招一些这么贵的人，一般的企业肯定受不了。所以将来要么是大规模公有云平台，要么是土豪如电信金融行业的自建云平台，都会出现超大规模的场景，基于 AIOps 和智能调度节约成本，就是势在必然的了。 InfoQ：QCon 广州的「微服务实战」专题下设置了 4 个演讲，作为出品人，你如何策划这 4 个演讲，想给参会者呈现微服务的哪些方面？刘超：基于我们自己的微服务实践，和对于微服务发展阶段的理解，作为「微服务实战」专题的出品人，我计划全方位展示微服务在主流公司的主流技术方向的实践和未来方向。 第一个方面就是基于 Dubbo 的大规模微服务实践的场景，Dubbo 是应用范围非常广的微服务框架，很多企业都是基于 Dubbo 做的，Dubbo 的实践是微服务实施过程中绕不过去的一环，这个主题能够解决很多技术人员实施海量 Dubbo 服务的时候遇到的问题。 第二个方面就是基于 Spring Cloud 的大规模微服务实战的场景，Spring Cloud 是近年来新兴的微服务框架，很多新实施微服务的，会选择基于 Spring Cloud，但是 Spring Cloud 虽然组件丰富，可选项多，但是也很复杂，学习曲线高，如何再海量场景下进行改进和适配，是经常遇到的问题，这个主题能够给予技术人员实施 Spring Cloud 微服务的时候以借鉴意义。 第三个方面就是Service Mesh 在高并发场景下的实践场景，前面说了 Service Mesh 是一个趋势，一线互联网公司都在尝试，但是这个技术太新了，很多坑还在踩，这个主题能够带给技术人员最前沿微服务技术的落地实践，给想试试 Service Mesh 的技术人员以借鉴意义。 第四个方面就是微服务框架各个方向的发展与未来趋势，微服务涉及范围广，技术选型难，很多没有实施微服务的技术人员面临如此多的技术名词，无所适从，选稳定的，会不会过时被淘汰，选先进的，会不会冒进出线上事故，选错了技术方向，万一开源的不维护了就麻烦大了，这个主题会讲解微服务发展的技术趋势和各个方向的优劣对比，给选型困难的技术人员以参考。]]></content>
      <categories>
        <category>微服务专题</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git操作指南]]></title>
    <url>%2Fmoblog.github.io%2Fgit%2Fgit%2F</url>
    <content type="text"><![CDATA[——————————git配置以及公钥生成————————————1、安装git命令行设置$ git config –global user.name “Your Name” 配置用户名$ git config –global user.email “email@example.com“ 配置邮件 2.生成并部署SSH key 你可以按如下命令来生成 sshkey: ssh-keygen -t rsa -C “xxxxx@xxxxx.com“ Generating public/private rsa key pair…三次回车即可生成 ssh key查看你的 public key，并把他添加到码云（Gitee.com）或 github （github.com） 的SSH上 cat ~/.ssh/id_rsa.pub（公钥的文件） ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc….添加后，在终端（Terminal）中输入ssh -T git@git.oschina.net若返回 Welcome to Git@OSC, yourname!则证明添加成功。——————————–项目中常用的git操作———————————————1.克隆项目git clone url(一般用ssh格式)2.先git pull2.添加自己修改的文件git add . 修改过的所有文件添加到git仓库git commit进入vim编辑，写注释 1、k,j,h,l 光标上下左右 （也可以使用上下左右键）2、o 在当前行下方插入新行并进入插入模式 (一般写注释，注释要详细)3、:wq 保存并退出注意：注释添加完毕后需要先将输入法切换为英文并按ESC键输入:wq指令后按Enter 3.提交代码git push 注：先git pull 下载解决冲突（必要时手动解决冲突）再git push 提交服务器 “svn的流程与git相似，但是svn是可视化的工具，也是分为三步走：新建文件夹克隆代码–&gt;svn updata–&gt;svn commit”如果有不想提交的文件可以使用：.gitignore文件（如node_modules的提交）详细文档请查看：https://git.oschina.net/hjm100/codes/cqylm4gubre1f9ax23hw594 git commit 标准用法： 不推荐使用 -m 简单模式 推荐使用编辑器提供详细的提交信息： 提交内容概要 &lt;—-注意此处必须有空行—-&gt; 提交内容1 提交内容2 提交内容3 …【注意：合并者要保证代码格式，否则会被别人鄙视！】—————————–git常用指令———————————–git init 在本地初始化一个Git库git clone 将远程服务器上的项目文件夹包括.git隐藏文件丝毫不差地下载到本地git add file 添加文件到git库git commit -m 添加注释，一般可以是总结做的事情git commit –amend 使用 –amend 可以修补提交消息（可在修改后先 git add 再 git commit –amend 修补刚才的提交）git pull 从远程git库中拉取最新内容并合并，它相当于 git fetch 和 git mergegit push 将本地git库推送到远程git库 推送时有2种可能： 1、远程git库自从上次pull之后没有发生过变化快速向前自动完成 2、远程git库已经被其他人push了新内容git push origin blue -u 将本地分支推送到远程git库（origin）-u 将本地分支和远程git库中的blue分支关联起来git push &lt;远程git库名称&gt; –tags 将所有标签推送到远程git库git remote 查看与本地git库关联所有远程git库（一个本地git库可以向多个远程git库推送）git remote -v 查看远程库的url及权限（verbose详细信息）git remote show &lt;远程库名字&gt; 可以查看远程的基本信息（如：主分支名字，全部分支的列表，本地库和远程库之间的差异）git tag &lt;标签名&gt; 在最近的提交上打标签git show &lt;标签名&gt; 显示标签信息（标签打在了哪次提交上）git tag 列出所有标签git tag -d &lt;标签名&gt; 删除标签git tag -a &lt;标签名&gt; -m “打标签的原因” 新增附注标签，附加有备注信息及打签人和打签时间的标签git log 查看历史提交，方便回退git status 告诉你工作区的当前状态git diff 查看修改内容git config –global -l 查看全局配置（当前用户目录中的 .gitconfig 文件）git reset –hard 版本id 回退到某一个版本git reflog 查看命令历史git rm file 从版本库中删除一个文件注意：注意如果不提交，这次删除不会保存在git库中，想要保存需要提交commit。文件删除之后，通过checkout 找不回这个文件，如果想要找到这个文件采用回退命令。git checkout – file 从git库中获取一个文件版本替换工作区文件版本。git checkout -b 分支名 如果分支不存在创建新分支， 然后切换到这个分支工作区（work directory）、暂存区（stage）、master修改git默认编辑的方法： git config –global core.editor “编辑器名字或路径 -w” -w 表示git需要等待编辑器窗口关闭再提交 ——————————git合并命令以及vim编辑器————————————– git log 打印提交记录，如果显示过多，按回车继续打印，按q退出日志打印git merge 分支名 合并指定分支到当前分支，有多种分支合并模式，Fast Forward最简单，最快速，不需要人参与echo 内容&gt;&gt;文件名 创建文件，并将内容注入到文件中vim 文件名 使用vim编辑文件，命令行编辑器h 光标向前l 光标向后j 光标向下k 光标向上i 进入插入模式（输入模式）默认vim进入的是命令模式，命令模式下按键时执行命令，插入模式下按键插入字符:wq 保存并退出:q! 不保存退出o 在当前行下方插入新行并进入插入模式vimtutor vim入门教程v 可视化选区d 删除可视化选区并记录删除的内容p 粘贴内容u 撤消 合并冲突、解决冲突实际上就是人工修改代码 git log –graph 以“图形”化的方式显示提交记录 可以很方便地查看各分支提交情况 git生成删除以及切换分支 在本地新建一个分支： git branch newBranch切换到你的新分支: git checkout newBranch将新分支发布在github上： git push origin newBranch在本地删除一个分支： git branch -d newBranch在github远程端删除一个分支： git push origin :newBranch (分支名前的冒号代表删除) 备注：在Git操作中你不需要了解太多指令，只需要熟记项目中常用的指令即可，希望有兴趣的朋友，可以自己操作上手一下（可以搭建自己的项目）熟能生巧，读万卷书不如行万里路，谢谢！！！！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写技术简历]]></title>
    <url>%2Fmoblog.github.io%2Fcv%2Fcv%2F</url>
    <content type="text"><![CDATA[Java程序员简历模板本简历模板由国内首家互联网人才拍卖网站「 JobDeer.com 」提供。 （括号里的是我们的顾问编写的说明，建议在简历书写完成后统一删除） 先讲讲怎样才是一份好的技术简历首先，一份好的简历不光说明事实，更通过FAB模式来增强其说服力。 Feature：是什么 Advantage：比别人好在哪些地方 Benefit：如果雇佣你，招聘方会得到什么好处 其次，写简历和写议论文不同，过分的论证会显得自夸，反而容易引起反感，所以要点到为止。这里的技巧是，提供论据，把论点留给阅读简历的人自己去得出。放论据要具体，最基本的是要数字化，好的论据要让人印象深刻。 举个例子，下边内容是虚构的： 2006年，我参与了手机XX网发布系统WAPCMS的开发（这部分是大家都会写的）。作为核心程序员，我不但完成了网站界面、调度队列的开发工作，更提出了高效的组件级缓存系统，通过碎片化缓冲有效的提升了系统的渲染效率。（这部分是很多同学忘掉的，要写出你在这个项目中具体负责的部分，以及你贡献出来的价值。）在该系统上线后，Web前端性能从10QPS提升到200QPS，服务器由10台减少到3台（通过量化的数字来增强可信度）。2008年我升任WAPCMS项目负责人，带领一个3人小组支持着每天超过2亿的PV（这就是Benefit。你能带给前雇主的价值，也就是你能带给新雇主的价值。）。 有同学问，如果我在项目里边没有那么显赫的成绩可以说怎么办？讲不出成绩时，就讲你的成长。因为学习能力也是每家公司都看中的东西。你可以写你在这个项目里边遇到了一个什么样的问题，别人怎么解决的，你怎么解决的，你的方案好在什么地方，最终这个方案的效果如何。 具体、量化、有说服力，是技术简历特别需要注重的地方。 （以上内容在写完简历后，对每一段进行评估，完成后再删除） 联系方式（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便） 手机：135** （如果是外地手机，可注明。如经常关机，要写上最优联系时间） Email：goodman@gmail.com （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G） QQ/微信号：6***（提供一个通过网络可以联系到你的方式） 个人信息 胶布帝/男/1990 本科/萌鹿大学计算机系 工作年限：3年 微博：@JobDeer （如果没有技术相关内容，也可以不放） 技术博客：http://blog.github.io ( 使用GitHub Host的Big较高 ) Github：http://github.com/geekcompany ( 有原创repo的Github帐号会极大的提升你的个人品牌 ) 期望职位：Java高级程序员，架构师 期望薪资：税前月薪15k~20k，特别喜欢的公司可例外 期望城市：北京 工作经历（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组） ABC公司 （ 2012年9月 ~ 2014年9月 ）DEF项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 GHI项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） JKL公司 （ 2010年3月 ~ 2012年8月 ）MNO项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 PQR项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） 开源项目和作品（这一段用于放置工作以外的、可证明你的能力的材料） 开源项目（对于程序员来讲，没有什么比Show me the code能有说服力了） STU：项目的简要说明，Star和Fork数多的可以注明 WXYZ：项目的简要说明，Star和Fork数多的可以注明 技术文章（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你） 一个产品经理眼中的云计算：前生今世和未来 来自HeroKu的HTTP API 设计指南(翻译文章) （ 好的翻译文章可以侧证你对英文技术文档的阅读能力） 演讲和讲义（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义） 2014架构师大会演讲：如何通过Docker优化内部开发 9月公司内部分享：云计算的前生今世 技能清单（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错） 以下均为我熟练使用的技能 Web开发：PHP/Hack/Node Web框架：ThinkPHP/Yaf/Yii/Lavaral/LazyPHP 前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic 前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap 数据库相关：MySQL/PgSQL/PDO/SQLite 版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer 单元测试：PHPUnit/SimpleTest/Qunit 云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发 参考技能关键字本技能关键字列表是从最近招聘Java的数百份JD中统计出来的，括号中是出现的词频。如果你的简历要投递给有机器（简历分选系统）和不如机器（不懂技术的HR）筛选简历环节的地方，请一定从下边高频关键词中选择5～10个适合你自己的。 java(730) spring(305) web(260) mysql(250) oracle(207) linux(198) j2ee(182) javascript(177) sql(176) hibernate(169) html(139) tomcat(132) struts(128) jquery(116) jsp(106) ajax(96) css(94) ibatis(84) mvc(77) servlet(71) xml(70) js(62) eclipse(51) mybatis(51) jboss(47) struts2(47) weblogic(46) redis(46) apache(45) http(44) shell(39) python(38) hadoop(37) nosql(35) ssh(35) sqlserver(33) mongodb(33) svn(32) uml(32) json(27) unix(27) maven(27) nginx(26) webservice(25) jdbc(24) memcached(23) tcp(22) resin(22) jvm(21) socket(21) db2(19) springmvc(19) websphere(16) soa(16) mina(14) android(14) extjs(13) erp(12) memcache(12) api(11) jetty(11) myeclipse(11) ext(10) git(10) jpa(10) svm(9) php(9) jms(9) ruby(9) lucene(8) html5(8) postgresql(8) crm(7) javaee(7) sybase(7) freemarker(6) cache(6) jsf(6) j2se(6) jbpm(6) cvs(6) junit(6) visio(6) netty(6) hbase(6) nio(6) powerdesigner(6) oo(6) aop(6) workflow(5) restful(5) ios(5) ant(5) mssql(5) orm(5) rose(5) solr(5) webwork(5) zookeeper(4) soap(4) o2o(4) wap(4) cxf(4) thrift(4) xmpp(3) p2p(3) javabean(3) jee(3) hdfs(3) dom(3) hibernate3(3)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>简历模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web 框架技术选型的原则]]></title>
    <url>%2Fmoblog.github.io%2Fweb%2Fweb%2F</url>
    <content type="text"><![CDATA[引言 首先对于一家创业公司而言，这更像是一个商业抉择而不仅仅是技术选择，时间人力物力等开销都必须要考虑周全。一旦公司规模上来了资金不成问题了，可选择的空间就更大了甚至可以进行迁移或重新架构。原文作者 Ramigbtech 总结了以下 10 点以供参考。 1. 语法拥有优雅语法的语言无疑可以让编程工作变得惬意，但有时候我们容易被表象所蒙蔽，如果凭直觉你认定，”this is text”.split (’ ‘) .reverse.join (‘ ‘)比” “.join (“This is text”.split (’ ‘)[::-1]) 的写法要好或差，那么这仅仅是外貌协会，实际上我们更应该着眼于它本身是否具有局限性或语法是否累赘，用更少的代码完成等价的工作我们自己或团队都会对当初的选择心存感激。 2. 功能和体型我们需要为路由编写复杂的正则查询吗？路由中含有内建的 DSL 吗？我们需要使用 ORM 吗？或许我们还想拥有更多其它功能。建议选取一款较轻巧框架作为开始，日后我们可以为它添砖加瓦。 3. 文档资源具备丰富文档资源的框架使用起来的确是得心应手事半功倍。nt例如我在学习 CodeIgniter 时，根本不必像无头苍蝇那样四处寻找答案，其自带的教程和配套范例都做得非常认真仔细。相对而言，我在学习 ExpressJS 的时候就比较费力了。 4. 代码自动生成框架中的代码自动生成功能通常能为我们节省不少时间，我们仅需要做好控制器/类等的处理而把其它重复的编码工作交给框架，虽然有时候不能自由地进行自定义，但对于想快速开发出一个能运行的原型是有积极意义的。 5. 模块化Django 在模块/Apps 的处理上令人赞叹，不仅仅让代码复用变得简便，同时有助我们培养良好的模块化思维。当我们不再需要X模块时，我们只需把它移除然后做好代码重构工作就可以了。 6. 基础架构不论是使用 LAMP 还是 MEAN 堆栈，或是 Rails/Unicorn 等，最关键的还是我们对这个架构有没有足够的了解，有没有相关组件的维护能力。假如应用的前端和后端都与 Javascript 相关，采用 MEAN 堆栈架构是个不错的选择。 7. 社区和更新速度框架相关的社区是否活跃？有没有技术大咖坐镇？官方会否常常上 StackOverflow 帮忙解答技术疑难？为这些问题找到完美的答案是有一定难度，但绝大多数时候数字是最真实的。日期或参与度/帖子热度都是不错的衡量指标。此外，补丁的更新速度也十分关键，对安全性和漏洞的重视与否可谓是牵一发而动全身。 8. 重大变更就在最近不少程序员听到 Angular 2.0 的重大变更后感到震惊和抓狂，尽管要到 2015 年晚些时候才会全部完成，但一想到辛辛苦苦做好的代码都会变成过去时，又怎能安之若素呢？另一个例子是 Yii 框架，新版本 2.0 的推出意味着对前个版本的完全重写。 9. 部署和依赖容易部署吗？能方便进行扩展吗？需要花费多少时间来学习掌握部署工具？虽然有 Docker 这样的工具可以帮我们解答上述问题，但是抽取时间来思考这方面的问题还是有必要的。 10. 人力我们能快捷地找到相应的开发人才吗？将要使用的框架在我们所处的区域是否流行？纵然培训工作是管理的一部分，但对于初创公司而言时间和资金时刻都得精打细算。 最后：如果是中型的网站，我会选择 Django。如果我暂时不能确定网站的规模和将投入多少开发精力，我会选择 Rails。如果我不想前后端工作分得太开，我会选择 MEAN 堆栈。]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>框架</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Spring Boot看这两个开源项目就够了！非得值得收藏的资源]]></title>
    <url>%2Fmoblog.github.io%2Fjpa%2Fspringboot%2F</url>
    <content type="text"><![CDATA[引言 Spring Boot我就不做介绍了，大家都懂得它是一个多么值得我们程序员兴奋的框架 为什么要介绍这两个开源项目呢？ 提供了丰富的学习实践案例 整合了非常多优质的学习资源 链接地址 121.https://github.com/ityouknow/spring-boot-examples(纯洁的微笑)2.https://github.com/JeffLi1993/springboot-learning-example]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发中MyBatis、Hibernate、Spring Data JPA应该如何选择？]]></title>
    <url>%2Fmoblog.github.io%2Fjpa%2Fjpa%2F</url>
    <content type="text"><![CDATA[引言 大家知道目前Java开发中MyBatis、Hibernate、Spring Data JPA是3个使用比较普遍的持久化框架，但是我们在实际项目中应该如何选择呢？我们对此做一下分析。 一.简单介绍 Hibernate Hibernate是将POJO通过Xml映射文件（或注解）提供的规则映射到数据库表上，是一种全表映射的模型，可以通过POJO直接操作数据库。我们不需要写SQL，只要使用HQL语言就可以了。 MyBatis Mybatis是半自动的框架。之所以说它是半自动的，是因为它需要手工匹配提供POJO、SQL和映射关系，而Hibernate只需要提供POJO和映射关系即可。 Spring Data JPA Spring Data JPA是在JPA规范的基础下提供了Repository层的实现，是对ORM框架的进一步抽象封装，它不直接代替ORM框架，默认底层使用的ORM框架是Hibernate，但可以灵活的在各种ORM框架之间切换，同时也简化了我们对ORM框架的使用。 综上，使用Hibernate的可以使用Spring Data JPA来简化开发了。我们只需要在MyBatis和Spring Data JPA之间做选择，而这个选择还是得看MyBatis和Hibernate的对比。 二.优缺点Java开发中MyBatis、Hibernate、Spring Data JPA应该如何选择？ 1.MyBatis1.1.优点它是一个半自动化的持久层框架，支持动态SQL，灵活可控。更容易掌握，入门简单，即学即用，学习成本低。 1.2.缺点需要维护SQL和结果映射，增加了工作量。移植性差，所有的SQL语句都依赖所用的数据库，对不同数据库类型的支持不好。 2.Hibernate2.1.优点不需要维护SQL和结果映射，开发工作量少。移植性好，所有的 HQL 语句与具体使用的数据库无关。 2.2.缺点性能相对较差。学习门槛不低，精通门槛更高，学习成本高。 三.适用场景Java开发中MyBatis、Hibernate、Spring Data JPA应该如何选择？ 1.MyBatis数据量大，高并发。表关联比较复杂。要求对于数据库可控性好， 可深度调优。 2.Hibernate场景不太复杂。需求变化不多。性能要求不高。 四.总结目前来看传统企业使用Spring Data JPA的比较多，而互联网行业更倾向于使用MyBatis，如阿里及其旗下的很多子公司都在用MyBatis。在实际使用时可以结合各个框架的优缺点、项目情况、研发人员的技术情况等综合评估和选择。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>SQL</tag>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkjs-cmswing]]></title>
    <url>%2Fmoblog.github.io%2Fthinkjs%2Fthinkjs%2F</url>
    <content type="text"><![CDATA[特别提示项目依赖本项目已升级到ThinkJS 3.0 ,项目运行的 Node &gt; 7.6.0（推荐使用 8.x.x 版本）; 项目源代码地址 github地址：https://github.com/arterli/CmsWing 码云地址：http://git.oschina.net/arterli/CmsWing 简介: 模块化：全新的架构和模块化的开发机制，便于灵活扩展和二次开发。 模型/栏目/分类信息体系：通过栏目和模型绑定，以及不同的模型类型，不同栏目可以实现差异化的功能，轻松实现诸如资讯、下载、讨论和图片等功能。通过分类信息和栏目绑定，可以自动建立索引表，轻松实现复杂的信息检索。 用户行为：支持自定义用户行为，可以对单个用户或者群体用户的行为进行记录及分享，为您的运营决策提供有效参考数据。 云服务支持：支持云存储、云安全、云过滤和云统计等服务，更多贴心的服务让您的网站更安心。 安全稳健：提供稳健的安全策略，包括备份恢复、容错、防止恶意攻击登录，网页防篡改等多项安全管理功能，保证系统安全，可靠、稳定的运行。 快速入门本项目依赖,nodejs &gt;7.6.5 推荐使用 8.x.x 版本 mysql &gt; 5.X git clone源代码,或者下载指定版本; 1git clone https://gitee.com/arterli/CmsWing.git 发行版本选择,建议最新版本 https://gitee.com/arterli/CmsWing/releases 进入命令行模式 cd 到CMSWing目录下 安装项目依赖 1npm install 创建项目需要的数据库,登录MySQL 创建数据库, 数据库名字可以随意, 1create database cmswing; 查看数据库,是否创建成功,看到有 cmswing的数据库,就创建成功了 1show databases; 登录数据库,使用数据库, 1use cmswing; 返回 Database changed 说明成功,下一步 导入SQL文件,生成数据库表,SQL文件在CMSWing根目录, 目录改成,自己的 cmswing.sql 文件目录 1source D:\ProjectList\NodeJS\CmsWing\cmswing.sql 导入完成后,配置数据库 配置项目使用的数据库账号密码端口 在CmsWing\src\config目录下的model.js文件中配置你的数据库 改数据库用户名,密码,数据库,端口一般默认 1234567891011121314mysql: &#123; handle: mysql, // Adapter handle user: &apos;root&apos;, // 用户名 password: &apos;root&apos;, // 密码 database: &apos;cmswing&apos;, // 数据库 host: &apos;127.0.0.1&apos;, // host port: 3306, // 端口 connectionLimit: 1, // 连接池的连接个数，默认为 1 prefix: &apos;cmswing_&apos;, // 数据表前缀，如果一个数据库里有多个项目，那项目之间的数据表可以通过前缀来区分 cache: &#123; // 额外的缓存配置 type: &apos;file&apos;, handle: fileCache, cachePath: path.join(think.ROOT_PATH, &apos;runtime/cache&apos;) // absoulte path is necessarily required &#125; 配置完,运行项目 1npm start 查看有没有报错,没有直接访问,http://127.0.0.1:8360 前端登录 账号密码 12user: adminpassword: 123456 愉快的玩耍吧,里面有默认的数据 管理后台登录账号密码一样 http://127.0.0.1:8360/admin QQ 交流群: 49757468有问题可以到QQ群 进行交流. install dependencies1npm install start server1npm start deploy with pm2use pm2 to deploy app on production envrioment. 1可以在项目根目录下执行 pm2 start pm2.json 来启动项目 后台账号密码112账号:admin密码:123456 演示网站#####PC端直接输入下面网址: CmsWing.com www.cmswing.com CMSWing 官网.CmsWing.net www.cmswing.net CMSWing 演示网站.LVOOwww.lvoo.net 分类信息应用案例展示。 #####手机端,用手机浏览器或者微信客户端扫下面二维码: 内置模型 - 同时支持PC端与手机端【微信公众平台】新闻系统模型下载系统模型视频系统模型图库系统模型商城系统模型问答社区模型##后台部分截图 ##手机端(微信)前台模版截图]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>thinkjs</tag>
        <tag>cms</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sunny-ngrok内网穿透]]></title>
    <url>%2Fmoblog.github.io%2Fsunny-ngrok%2Fsunny-ngrok%2F</url>
    <content type="text"><![CDATA[前言 为什么使用Sunny-Ngrok？ 提供免费内网穿透服务，免费服务器支持绑定自定义域名 管理内网服务器，内网web进行演示 快速开发微信程序和第三方支付平台调试 本地WEB外网访问、本地开发微信、TCP端口转发 本站新增FRP服务器，基于 FRP 实现https、udp转发 无需任何配置，下载客户端之后直接一条命令让外网访问您的内网不再是距离 ngrok12345登录帐号：******@163.com登录密码：Mcgrady:****域名：http://mymo.free.idcfengye.com映射内网：127.0.0.1:10005(内网端口需要自行修改)隧道id:sunny.exe clientid 7bb09a527ea35e6e sunny.exe]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swagger注解]]></title>
    <url>%2Fmoblog.github.io%2Fswagger%2Fswagger%2F</url>
    <content type="text"><![CDATA[#前言 swagger注解]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express安装]]></title>
    <url>%2Fmoblog.github.io%2Fexpress%2Fexpress%2F</url>
    <content type="text"><![CDATA[前言 在你的windows上已经安装了node.js的基础上再安装express 第一部分:安装express 第一步:执行 npm install -g express-generator note:必须安装这个,不然创建express项目的时候会提示express命令没有找到 第二步:执行 npm install -g express 第三步:执行 express -V 或者 express –version note:’V’是大写的,如果express安装成功会显示版本号 第二部分:创建一个express项目 第一步:执行 express youProjectName note:youProjectName是你的项目的名称,按照自己的要求选择合适的项目名称 第二步 :进入你的项目:cd youProjectName 第三步:在你的项目的目录下执行 npm install 第四步:启动你的项目,执行 npm start 第三部分:在浏览器中访问你的项目 打开你的浏览器,在地址栏中输入:http://127.0.0.1:3000 然后你会看到:express的欢迎信息 最后:开启你的express之旅吧,祝君工作愉快!]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最实用的 Markdown 语法教程]]></title>
    <url>%2Fmoblog.github.io%2Fmarkdown%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[前言 最近不是很忙,仔细研究了一下Markdown语法,忽然有种相见恨晚的感觉,因为用它来写文档，那是相当的舒服，特别feeling。废话少说，咱们开始正题吧〜 培训内容： Markdown 是什么？ Markdown 是谁创造的？ 为什么要使用Markdown? Markdown怎么使用？ Markdown 都有哪些人在用？ 尝试一下Markdown的使用！ Markdown 进阶语法！ 学习目标 通过学习，能对Markdown语法有个比较全面的认知，对日常工作写作排版尽量放弃Word、txt等文本工具，改直接用Markdown语言写文档。 学思路 12345678910111.一开始，先记住 # 这是标题、## 这是二级标题、### 这是三级标题、...这时候你写一般小文章会开始感觉 MD 不错。2.然后，你发现标题不适合做列表，记住了用1. 第一点、- 这一点来列表超级方便。3.好吧，写作总要有些重点吧，**加粗**、*斜体*、~~删除线~~开始派上用场了。这时你基本不会打开 Word 那样的笨重软件了。4.&gt; 这是引用5.你越来越喜欢，自然会去查查维基（Markdown）还有什么语法，加上多用，很快就基本掌握了。MD 还有表格、锚、注脚、贴图等。强烈推荐 Mou，按 ⌘＋R 可以快速查看语法。6.慢慢，你会发现，总有小「bugs」，如列表内无法内嵌代码段。上网查查，你开始理解 MD 的缩进内嵌机制等高级隐形内容，这样你就 Master 了！ 以下是 Mou 下面的效果，多么漂亮： Mou 写出的效果 正文 一、Markdown是什么？ Markdwon 是一种轻量级 标记语言，它以纯文本形式（易读、易写、易更改）编写文档，并最终以HTLM格式发布。Markdown也可以理解为将以 MARKDOWN语法编写的语言转换成HTML内容的工具。 二、Markdown是谁创造的？ 它是由 Aaron Swartz 和 John Gruber 共同设计， Aaron Swartz 就是那位（2013年1月11日）自杀，有着开挂一般人生经历的程序员。 维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。他有着足以让你跪拜的人生经历。 14岁参与RSS 1.0规格标准制订。 2004年入读斯坦福大学，之后退学。 2005年创建 Infogami,之后与Reddit合并成为其合伙人。 2010年创立示进会（Demand Preogress）,积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。 2011年7月19日,因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。 Aaron Swartz 大神照片 三、为什么要使用Markdown? 它是易读（看起来舒服😌）、易写（语法简单）、易更改（纯文本）。处处体现着极简主义的影子。 兼容HTML,可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown. 更方便清晰的组织你的电子邮件。（Markdown-here,Airmail）。 摆脱Word,txt！！！ 四、Markdown怎么使用？ 如果不算扩展，Markdown的语法绝对简单到让你爱不释手！Markdown语法分为如下几大部分：▸ 标题▸ 段落▸ 区块引用▸ 代码区块▸ 强调▸ 列表▸ 分割线▸ 链接▸ 图片▸ 反斜杠▸ 符号▸ 表格▸ 流程图 4.1 标题####### 1）使用= 和 -，标记一级和二级 标题。 12345示例md代码:一级标题=二级标题- 示例效果： ####### 2）使用 #,可以表示 1-6级 标题。1234567示例md代码:# 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ### 第三级标题 `&lt;h3&gt;` #### 第二四级标题 `&lt;h4&gt;` ##### 第五级标题 `&lt;h5&gt;` ###### 第六级标题 `&lt;h6&gt;` 示例效果： 4.2 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车） 4.3 区块引用在段落的每行或者只在第一行使用符号 &gt; ,还可使用多个嵌套引用，如：12345示例md代码:&gt; 区块引用&gt; &gt; 嵌套引用&gt; &gt; &gt;三嵌套引用&gt; &gt; &gt; &gt; 四嵌套引用 示例效果： 4.4代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落：1234567891011121314151617181920212223242526272829303132333435示例md代码:fun main(args: Array&lt;String&gt;) &#123; println(&quot;Hello World!&quot;) println(&quot;sum = $&#123;sum(34, 67)&#125;&quot;) println(&quot;sum = $&#123;sum(34, 67)&#125;&quot;) println(&quot;sum = $&#123;sum(34, 6, 57, 34)&#125;&quot;) printSum(237, 57) printSum(234, 567, 8) vars(1, 4, 6, 78, 0, 6, 9, 8) val sumLambda: (Int, Int) -&gt; Int = &#123; x, y -&gt; x + y &#125; println(&quot;sumLambda = $&#123;sumLambda(3, 6)&#125;&quot;)// if (args.size &lt; 2) &#123;// println(&quot;Two integers expected&quot;)// return// &#125; testFor() val a: Int = 1000 println(a === a)//true 值相等，对象地址相等 //经过了装箱，创建了两个不同的对象 val boxedA: Int? = a val anotherBoxedA: Int? = a //虽然经过了装箱，但是值是相等的，都是10000 println(boxedA === anotherBoxedA) // false，值相等，对象地址不一样 println(boxedA == anotherBoxedA) // true，值相等&#125; 注意⚠️：需要和普通段落之间存在空行！ 4.5 强调在强调内容两侧分别加上 *或者 -,如：123示例md代码:*斜体* ，_斜体_**加粗**，__粗体__ 示例效果： 4.6 列表 （有序，无序）使用 . 、+、或- 标记无序列表，如：1234567示例md代码:- 第一项+ 第二项- 第三项+ 第四项- 第五项+ 第六项 示例效果:注意：标记后面最少有一个_空格_或制表符。若不在引用区块 中，必须和前方段落之间存在空行。 示例md代码:1234561. 第一项2. 第二项3. 第三项4. 第四项5. 第五项6. 第六项 示例效果: 4.7 分割线分割线最常使用就是三个或以上的 * ， ======还可以使用 - 和 _。 示例md代码:1234***---_____ ====== 示例效果: 4.8链接链接可以由两种形式生成，行内式 和 参考式。 行内式：示例md代码:12[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; 示例效果: 参考试：123[GitHub][1][1]:http://github.com自动生成连接 &lt;http://www.github.com/&gt; 示例效果: 注意：上述的 [1]:http://github.com 不出现在区块中。 4.9 图片添加图片形式和链接相似，只需要在链接的基础上前方加一个 ！号。示例md代码:12![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)格式: ![Alt Text](url) 4.10 反斜杠 ‘’相当于反转义作用。使符号成为普通符号。 4.11 符号 起到标记作用，如标签：Ctrl+A 、Ctrl+C、Ctrl+V 4.12 表格1234567示例md代码:第一格表头 | 第二格表头---------| -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格内容单元格 第一列第三格 多加文字 | 内容单元格第二列第三格内容单元格 第一列第四格 多加文字 | 内容单元格第二列第四格 示例效果: 4.12 流程图1234567891011示例st=&gt;start: Start:&gt;https://www.jpjbp.com/io=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考 五、Markdown都哪些人在用？ Markdown 的使用作者： Github、 简书、 StackOverFlow、 Apollo、 Moodle、 Reddit、 CSDN 等等 六、尝试一下Markdown的使用！ Chrome下的插件诸如stackedit与markdown-here等非常方便，也不用担心平台受限。在线的dillinger.io评价也不错Windowns下的MarkdownPad也用过，不过免费版的体验不是很好Mac下的Mou是国人贡献的，口碑很好。Linux下的ReText不错。 Github传送门TOCMarkdown 语法：[TOC] 总结：通过这次学习，自己也对MD语法有一个全新的认识，万事开头难，只要你偿试用MD 写工作中的文档，从此告别Word ，TXT！！！我相信你也会喜欢上这门语言。此外，如有写的不对的地方，勿喷！！！ 欢迎指正！ 作者：KKKnight_ 链接：https://www.jianshu.com/p/f3147a804368 來源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23种设计模式]]></title>
    <url>%2Fmoblog.github.io%2FdesignPattern%2FdesignPattern%2F</url>
    <content type="text"><![CDATA[前言 断断续续写了一段时间的设计模式，下面对这些设计模式总结一下 设计模式的分类设计模式一般分为三类：创建型模式、结构型模式、行为型模式。 创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。 结构型模式：把类或对象结合在一起形成一个更大的结构。 行为型模式：类和对象如何交互，及划分责任和算法 如何用一句话总结23种设计模式 1 创建型模式 1234567891011创建型模式简单来说就是用来创建对象的。一共有五种：单例模式、建造者模式、工厂方法模式、抽象工厂模式、原型模式。单例模式 ：确保某一个类只有一个实例，并且提供一个全局访问点。建造者模式 ： 用来创建复杂的复合对象。工厂方法模式 ：让子类来决定要创建哪个对象。抽象工厂模式 ：创建多个产品族中的产品对象。原型模式 ：通过复制原型来创建新对象。 2 行为型模式 1234567891011121314151617181920212223行为型模式主要是描述类或者对象是怎样交互和怎样分配职责的。一共有十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。策略模式 ：封装不同的算法，算法之间能互相替换。状态模式 ：根据不同的状态做出不同的行为。责任链模式 ：将事件沿着链去处理。观察者模式 ：状态发生改变时通知观察者，一对多的关系。模板方法模式 ：定义一套流程模板，根据需要实现模板中的操作。迭代器模式 ：提供一种方法顺序访问一个聚合对象中的各个元素。备忘录模式 ：保存对象的状态，在需要时进行恢复。访问者模式 ：稳定数据结构中，定义新的操作行为。中介者模式 ：将网状结构转变为星型结构，所有行为都通过中介。解释器模式 ：定义语法，并对其进行解释。命令模式 ：将请求封装成命令，并记录下来，能够撤销与重做。 3 结构型模式 123456789101112131415结构型模式主要是用于处理类或者对象的组合。一共有七种：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。代理模式 ：控制客户端对对象的访问。组合模式 ：将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理。适配器模式 ：将原来不兼容的两个类融合在一起。装饰者模式 ：为对象添加新功能。享元模式 ：使用对象池来减少重复对象的创建。外观模式 ：对外提供一个统一的接口用来访问子系统。桥接模式 ：将两个能够独立变化的部分分离开来。 4 其他设计模式 1另外，除了这23种经典的设计模式，还涌现出其他的一些新的设计模式，比如：规格模式、对象池模式、雇工模式、黑板模式和空对象模式等等。后面有时间的话也会对这些模式进行分析。 最后虽然设计模式是个好东西，能够给我们带来各种好处，比如降低对象之间的耦合，增加程序的可复用性、可扩展性、可维护性等等。 但是我们也不应该滥用设计模式，设计模式在一定程序上会增加系统的复杂性。我们在写码时应该评估好各方面，避免过度设计。 另外，设计模式的各种角色也不是固定不变的，根据实际需要，我们可以适当的进行改动。 由于上面那23种经典的设计模式提出来的时间也比较久了，一些设计模式，比如解释器模式，在我们的实际开发中基本上用不到，了解一下就可以了。 同时，随着语言和技术的发展，有些模式可能已经过时。所以，我们要紧跟时代的发展]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mall]]></title>
    <url>%2Fmoblog.github.io%2FopenCoding%2FopenCoding%2F</url>
    <content type="text"><![CDATA[说明 基于SpringBoot+MyBatis的电商系统，包括前台商城系统及后台管理系统。 前言mall项目致力于打造一个完整的电商系统，采用现阶段流行技术实现。 项目介绍mall项目是一套电商系统，包括前台商城系统及后台管理系统，基于SpringBoot+MyBatis实现。前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。 项目演示 后台管理系统 前端项目mall-admin-web地址：https://github.com/macrozheng/mall-admin-web 项目演示地址： http://39.98.190.128/index.html 前台商城系统 前端项目mall-app-web地址：敬请期待…… 项目演示地址：http://39.98.190.128/mall-app/mainpage.html 组织结构123456mall├── mall-mbg -- MyBatisGenerator生成的数据库操作代码├── mall-admin -- 后台商城管理系统接口├── mall-search -- 基于Elasticsearch的商品搜索系统├── mall-portal -- 前台商城系统接口└── mall-demo -- 框架搭建时的测试代码 技术选型后端技术 技术 说明 官网 Spring Boot 容器+MVC框架 https://spring.io/projects/spring-boot Spring Security 认证和授权框架 https://spring.io/projects/spring-security MyBatis ORM框架 http://www.mybatis.org/mybatis-3/zh/index.html MyBatisGenerator 数据层代码生成 http://www.mybatis.org/generator/index.html PageHelper MyBatis物理分页插件 http://git.oschina.net/free/Mybatis_PageHelper Swagger-UI 文档生产工具 https://github.com/swagger-api/swagger-ui Hibernator-Validator 验证框架 http://hibernate.org/validator/ Elasticsearch 搜索引擎 https://github.com/elastic/elasticsearch RabbitMq 消息队列 https://www.rabbitmq.com/ Redis 分布式缓存 https://redis.io/ MongoDb NoSql数据库 https://www.mongodb.com/ Docker 应用容器引擎 https://www.docker.com/ Druid 数据库连接池 https://github.com/alibaba/druid OSS 对象存储 https://github.com/aliyun/aliyun-oss-java-sdk JWT JWT登录支持 https://github.com/jwtk/jjwt LogStash 日志收集 https://github.com/logstash/logstash-logback-encoder Lombok 简化对象封装工具 https://github.com/rzwitserloot/lombok 前端技术 技术 说明 官网 Vue 前端框架 https://vuejs.org/ Vue-router 路由框架 https://router.vuejs.org/ Vuex 全局状态管理框架 https://vuex.vuejs.org/ Element 前端UI框架 https://element.eleme.io/ Axios 前端HTTP框架 https://github.com/axios/axios v-charts 基于Echarts的图表框架 https://v-charts.js.org/ Js-cookie cookie管理工具 https://github.com/js-cookie/js-cookie nprogress 进度条控件 https://github.com/rstacruz/nprogress 架构图系统架构图 业务架构图 模块介绍后台管理系统 mall-admin 商品管理：功能结构图-商品.jpg 订单管理：功能结构图-订单.jpg 促销管理：功能结构图-促销.jpg 内容管理：功能结构图-内容.jpg 用户管理：功能结构图-用户.jpg 前台商城系统 mall-portal功能结构图-前台.jpg 开发进度 环境搭建开发工具 工具 说明 官网 IDEA 开发IDE https://www.jetbrains.com/idea/download RedisDesktop redis客户端连接工具 https://redisdesktop.com/download Robomongo mongo客户端连接工具 https://robomongo.org/download SwitchHosts 本地host管理 https://oldj.github.io/SwitchHosts/ X-shell Linux远程连接工具 http://www.netsarang.com/download/software.html Navicat 数据库连接工具 http://www.formysql.com/xiazai.html PowerDesigner 数据库设计工具 http://powerdesigner.de/ Axure 原型设计工具 https://www.axure.com/ MindMaster 思维导图设计工具 http://www.edrawsoft.cn/mindmaster ScreenToGif gif录制工具 https://www.screentogif.com/ ProcessOn 流程图绘制工具 https://www.processon.com/ PicPick 屏幕取色工具 https://picpick.app/zh/ 开发环境 工具 版本号 下载 JDK 1.8 https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html Mysql 5.7 https://www.mysql.com/ Redis 3.2 https://redis.io/download Elasticsearch 2.4 https://www.elastic.co/downloads MongoDb 3.2 https://www.mongodb.com/download-center RabbitMq 5.25 http://www.rabbitmq.com/download.html nginx 1.10 http://nginx.org/en/download.html 搭建步骤 本地环境搭建 本地安装开发环境中的所有工具并启动，具体参考deploy-windows.md; 克隆源代码到本地，使用IDEA或Eclipse打开，并完成编译; 在mysql中新建mall数据库，导入document/sql下的mall.sql文件； 启动mall-admin项目：直接运行com.macro.mall.MallAdminApplication的main方法即可，接口文档地址：http://localhost:8080/swagger-ui.html; 启动mall-search项目：直接运行com.macro.mall.search.MallSearchApplication的main方法即可，接口文档地址：http://localhost:8081/swagger-ui.html; 启动mall-portal项目：直接运行com.macro.mall.portal.MallPortalApplication的main方法即可，接口文档地址：http://localhost:8085/swagger-ui.html; 克隆mall-admin-web项目，并导入到IDEA中并完成编译传送门; 运行命令：npm run dev,访问地址：http://localhost:8090 即可打开后台管理系统页面; ELK日志收集系统的搭建：参考elk.md。 docker环境部署 在VirtualBox或其他环境中安装CenterOs7.2; 配置本地host:参考host.txt,将ip地址改为虚拟机的ip地址; 使用maven构建mall-admin、mall-search、mall-portal的docker镜像，参考docker.md中的使用maven构建Docker镜像; 部署步骤参考docker-deploy.md进行部署。 参考资料 Spring实战（第4版） Spring Boot实战 Spring Cloud微服务实战 Spring Cloud与Docker微服务架构实战 Spring Data实战 MyBatis从入门到精通 深入浅出MySQL 循序渐进Linux（第2版） Elasticsearch 技术解析与实战 MongoDB实战(第二版) Kubernetes权威指南 许可证MIT Copyright (c) 2018-2019 macrozheng]]></content>
      <categories>
        <category>电商系统</category>
      </categories>
      <tags>
        <tag>后台</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曾国藩语录]]></title>
    <url>%2Fmoblog.github.io%2Fzgf-say%2Fzgf-say%2F</url>
    <content type="text"><![CDATA[曾国藩：男人要想有出息，做到这六点，钱必定来追你！ 第一戒：久利之事勿为，众争之地勿往前半句是指：做人不可贪求过多！日中则移，月满则亏，物盛则衰世界上没有一劳永逸的事情，长久获利的事都是表面，背后隐藏危机，所以在利益面前头脑一定要清醒。后半句有两层意思：一是众人争执、争斗的地方你不要去，容易惹麻烦或者招致祸患。二是大家都去争抢的利益，你就不要去争抢了，因为那肯定是薄利。 第二戒：勿以小恶弃人大美，勿以小怨忘人大恩人无完人，所以我们不能因为别人的缺点就忽视了优点，也不要因为小小的恩怨就忽略了别人的大恩。人生难免会有做错事的时候，所以不要因为别人的一点小过失，一点道德上的小瑕疵，一点小恩怨，就全盘否定别人的好，忘记别人的恩情。 第三戒：说人之短乃护己之短，夸己之长乃忌人之长经常说别人短处的人，经常夸耀自己长处的人，可以说是“存心不厚，识量太狭。”俗话说，“打人不打脸，揭人不揭短。”经常谈论别人的短处，夸耀自己的长处，不仅是情商低的表现，也必然给自己招来怨恨，埋下祸乱的种子。 第四戒：利可共而不可独，谋可寡而不可众曹操能够“挟天子以令诸侯”，却终其一生不敢篡汉自立，他们都是怕成为众矢之的。所以，面对利益，一定要权衡取舍之道。《战国策》上说：“论至德者不和于俗，成大功者不谋于众。”谋求特别重大的事情，不必与众人商量。因为谋求大事的人，自己必定有非同一般的眼光、心胸与气度，自己看准了，去做就是了，如果和别人商量，反倒麻烦。人多七嘴八舌，会动摇你的意志，也会破坏你的信心和情绪。 第五戒：古今之庸人，皆以一惰字致败，天下古今之才人，皆以一傲字致败庸人，就是普通人，一般的人。对于一般的人来说，没有什么才气，只有勤奋工作才能成就事业，所以最忌讳一个“懒”字。曾国藩是勤劳的好例子，他其实并不聪明，但是却能以“勤”成就大学问和大事业，可以说正是普通人的榜样。而那些有才的人呢，虽然可凭才气走捷径，更容易成功，但也容易孤傲自大，故步自封，不肯向别人学习，这也是容易失败的。如项羽、李自成等，占尽天时地利，却因为骄傲而败亡。 第六戒：凡办大事，以识为主，以才为辅；凡成大事，人谋居半，天意居半所谓谋事在人，成事在天；曾国藩明确告诉我们，办大事要以“识”为主，才气、才能不过是辅助罢了。所以恃才傲物的人，往往难以成就大事，当然这里的“识”，不单单指知识，更指的是经验和见识。而“人谋居半，天意居半。”则是说，我们无论做什么事情，都要抱着“尽人事以听天命”的态度。不要因为有自己不能左右的的因素就不去努力，更不能因为自己努力了，最终却失败了而去怨天尤人。纵观人生，道阻且长，有许多机遇也有许多祸患。所以人生当戒则戒，方能无忧！——编辑 袭人]]></content>
      <categories>
        <category>曾国藩语录</category>
      </categories>
      <tags>
        <tag>曾国藩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HoorayOS_mini]]></title>
    <url>%2Fmoblog.github.io%2FHoorayOS-mini%2F</url>
    <content type="text"><![CDATA[===== 桌面应用数据 =====桌面通过读取data.js里的json数据显示桌面应用，其data.js可替换成后端输出，打开hros.app.js，找到17行，把data.js的路径替换成后端输出桌面json数据的地址即可。===== 应用结构参数说明 ===== 源码地址：https://github.com/QingShaoXi/Blog_Album/tree/master/HoorayOS_miniapp应用 id : 0, //应用id，确保该id唯一不重复，因为打开、关闭等操作都是根据这个唯一id来查找应用的title : “我的博客”, //应用名称type : “app”, //应用类型，分别有app、widget可选，app为窗口应用，widget为挂件应用icon : “img/ui/system-shapes.png”, //应用图标url : “http://www.cnblogs.com/hooray&quot;, //应用地址width : 1000, //应用显示宽度height : 500, //应用显示高度left : 100, //距离页面左部偏移量，不设置默认水平居中top : 100, //距离页面顶部偏移量，不设置默认垂直居中isresize : true, //应用是否可以拉伸isopenmax : false, //应用是否打开自动最大化状态isflash : false //应用是否为flash应用 widget应用 id : 0, //应用id，确保该id唯一不重复，因为打开、关闭等操作都是根据这个唯一id来查找应用的title : “我的博客”, //应用名称type : “widget”, //应用类型，分别有app、widget可选，app为窗口应用，widget为挂件应用icon : “img/ui/system-shapes.png”, //应用图标url : “http://www.cnblogs.com/hooray&quot;, //应用地址width : 1000, //应用显示宽度height : 500, //应用显示高度right : 100, //距离页面右部偏移量，不设置默认为0top : 100 //距离页面顶部偏移量，不设置默认为0 ===== 如何更换壁纸 ===== 打开index.html，找到：HROS.CONFIG.wallpaper = ‘img/wallpaper/wallpaper.jpg’;将后面的地址替换成其它壁纸图片链接即可 ===== 如何创建临时窗口和挂件 ===== 创建一个临时窗口，多次调用会多次创建，窗口不唯一 HROS.window.createTemp({title:’百度’,url:’http://hoorayos.com&#39;,width:800,height:400,left:100,top:100,isresize:false,isopenmax:false,isflash:false}); 创建一个临时挂件，多次调用会多次创建，窗口不唯一 HROS.widget.createTemp({url:’http://hoorayos.com&#39;,width:800,height:400,right:100,top:100}); 创建一个临时窗口，多次调用不会重复创建，窗口唯一，需要在参数里加上appid属性，内容随便填写，但确保appid唯一，以免与系统窗口重复参数说明：title：标题，url：网址，width：窗口宽度，height：窗口高度，left：挂件距离页面左部偏移量(可不填，默认0)，top：挂件距离页面顶部偏移量(可不填，默认0)，isresize：窗口是否可以拉伸(可不填，默认false)，isopenmax：窗口打开是否默认最大化(可不填，默认false)，isflash：窗口内是否为flash应用(可不填，默认false) HROS.window.createTemp({appid:’window_baidu’,title:’百度’,url:’hoorayos.com’,width:800,height:400,left:100,top:100,isresize:false,isopenmax:false,isflash:false}); 创建一个临时挂件，多次调用不会重复创建，窗口唯一，需要在参数里加上appid属性，内容随便填写，但确保appid唯一，以免与系统挂件重复参数说明：url：网址，width：窗口宽度，height：窗口高度，right：挂件距离页面左部偏移量(可不填，默认0)，top：挂件距离页面顶部偏移量(可不填，默认0) HROS.widget.createTemp({appid:’widget_baidu’,url:’hoorayos.com’,width:800,height:400,right:100,top:100});]]></content>
      <categories>
        <category>前端UI</category>
      </categories>
      <tags>
        <tag>仿window桌面webUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序接口调用凭证]]></title>
    <url>%2Fmoblog.github.io%2Faccess-token%2F</url>
    <content type="text"><![CDATA[请求地址1GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET java后端12345678910private static String tokenUrl = &quot;https://api.weixin.qq.com/cgi-bin/token&quot;;StringBuffer buffer = new StringBuffer(&quot;grant_type=client_credential&quot;);buffer.append(&quot;&amp;appid=&quot;+defaultConfig.getAppid());buffer.append(&quot;&amp;secret=&quot;+defaultConfig.getSecret());String result = HttpUtils.sendGet(tokenUrl,buffer.toString());JSONObject obj = JSONObject.parseObject(result);if(obj.get(&quot;errcode&quot;) != null)&#123; throw new BadRequestException(&quot;二维码生成异常&quot;);&#125; http请求工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310package com.zerocat.core.utils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.net.ssl.*;import java.io.*;import java.net.ConnectException;import java.net.SocketTimeoutException;import java.net.URL;import java.net.URLConnection;import java.security.cert.X509Certificate;import java.util.Iterator;import java.util.Map;/** * 通用http发送方法 * * @author zwx */public class HttpUtils&#123; private static final Logger log = LoggerFactory.getLogger(HttpUtils.class); /** * 向指定 URL 发送GET方法的请求 * * @param url 发送请求的 URL * @param param 请求参数，请求参数应该是 name1=value1&amp;name2=value2 的形式。 * @return 所代表远程资源的响应结果 */ public static String sendGet(String url, String param) &#123; StringBuilder result = new StringBuilder(); BufferedReader in = null; try &#123; String urlNameString = url + &quot;?&quot; + param; log.info(&quot;sendGet - &#123;&#125;&quot;, urlNameString); URL realUrl = new URL(urlNameString); URLConnection connection = realUrl.openConnection(); connection.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); connection.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); connection.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;); connection.connect(); in = new BufferedReader(new InputStreamReader(connection.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; result.append(line); &#125; log.info(&quot;recv - &#123;&#125;&quot;, result); &#125; catch (ConnectException e) &#123; log.error(&quot;调用HttpUtils.sendGet ConnectException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (SocketTimeoutException e) &#123; log.error(&quot;调用HttpUtils.sendGet SocketTimeoutException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (IOException e) &#123; log.error(&quot;调用HttpUtils.sendGet IOException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (Exception e) &#123; log.error(&quot;调用HttpsUtil.sendGet Exception, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; finally &#123; try &#123; if (in != null) &#123; in.close(); &#125; &#125; catch (Exception ex) &#123; log.error(&quot;调用in.close Exception, url=&quot; + url + &quot;,param=&quot; + param, ex.getMessage()); &#125; &#125; return result.toString(); &#125; /** * 向指定 URL 发送POST方法的请求 * * @param url 发送请求的 URL * @param param 请求参数，请求参数应该是 name1=value1&amp;name2=value2 的形式。 * @return 所代表远程资源的响应结果 */ public static String sendPost(String url, String param) &#123; PrintWriter out = null; BufferedReader in = null; StringBuilder result = new StringBuilder(); try &#123; String urlNameString = url + &quot;?&quot; + param; log.info(&quot;sendPost - &#123;&#125;&quot;, urlNameString); URL realUrl = new URL(urlNameString); URLConnection conn = realUrl.openConnection(); conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;); conn.setRequestProperty(&quot;Accept-Charset&quot;, &quot;utf-8&quot;); conn.setRequestProperty(&quot;contentType&quot;, &quot;utf-8&quot;); conn.setDoOutput(true); conn.setDoInput(true); out = new PrintWriter(conn.getOutputStream()); out.print(param); out.flush(); in = new BufferedReader(new InputStreamReader(conn.getInputStream(), &quot;utf-8&quot;)); String line; while ((line = in.readLine()) != null) &#123; result.append(line); &#125; log.info(&quot;recv - &#123;&#125;&quot;, result); &#125; catch (ConnectException e) &#123; log.error(&quot;调用HttpUtils.sendPost ConnectException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (SocketTimeoutException e) &#123; log.error(&quot;调用HttpUtils.sendPost SocketTimeoutException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (IOException e) &#123; log.error(&quot;调用HttpUtils.sendPost IOException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (Exception e) &#123; log.error(&quot;调用HttpsUtil.sendPost Exception, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException ex) &#123; log.error(&quot;调用in.close Exception, url=&quot; + url + &quot;,param=&quot; + param, ex.getMessage()); &#125; &#125; return result.toString(); &#125; /** * 向指定 URL 发送POST方法的请求 * * @param url 发送请求的 URL * @param paramMap 请求参数 * @return 所代表远程资源的响应结果 */ public static String sendPost(String url, Map&lt;String, ?&gt; paramMap) &#123; PrintWriter out = null; BufferedReader in = null; String result = &quot;&quot;; String param = &quot;&quot;; Iterator&lt;String&gt; it = paramMap.keySet().iterator(); while (it.hasNext()) &#123; String key = it.next(); param += key + &quot;=&quot; + paramMap.get(key) + &quot;&amp;&quot;; &#125; try &#123; URL realUrl = new URL(url); // 打开和URL之间的连接 URLConnection conn = realUrl.openConnection(); // 设置通用的请求属性 conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;Accept-Charset&quot;, &quot;utf-8&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;); // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); // 获取URLConnection对象对应的输出流 out = new PrintWriter(conn.getOutputStream()); // 发送请求参数 out.print(param); // flush输出流的缓冲 out.flush(); // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader(new InputStreamReader(conn.getInputStream(), &quot;UTF-8&quot;)); String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); &#125; //使用finally块来关闭输出流、输入流 finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; return result; &#125; @SuppressWarnings(&quot;deprecation&quot;) public static String sendSSLPost(String url, String param) &#123; StringBuilder result = new StringBuilder(); String urlNameString = url + &quot;?&quot; + param; try &#123; log.info(&quot;sendSSLPost - &#123;&#125;&quot;, urlNameString); SSLContext sc = SSLContext.getInstance(&quot;SSL&quot;); sc.init(null, new TrustManager[] &#123; new TrustAnyTrustManager() &#125;, new java.security.SecureRandom()); URL console = new URL(urlNameString); HttpsURLConnection conn = (HttpsURLConnection) console.openConnection(); conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;); conn.setRequestProperty(&quot;Accept-Charset&quot;, &quot;utf-8&quot;); conn.setRequestProperty(&quot;contentType&quot;, &quot;utf-8&quot;); conn.setDoOutput(true); conn.setDoInput(true); conn.setSSLSocketFactory(sc.getSocketFactory()); conn.setHostnameVerifier(new TrustAnyHostnameVerifier()); conn.connect(); InputStream is = conn.getInputStream(); DataInputStream indata = new DataInputStream(is); String ret = &quot;&quot;; while (ret != null) &#123; ret = indata.readLine(); if (ret != null &amp;&amp; !ret.trim().equals(&quot;&quot;)) &#123; result.append(new String(ret.getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;)); &#125; &#125; log.info(&quot;recv - &#123;&#125;&quot;, result); conn.disconnect(); indata.close(); &#125; catch (ConnectException e) &#123; log.error(&quot;调用HttpUtils.sendSSLPost ConnectException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (SocketTimeoutException e) &#123; log.error(&quot;调用HttpUtils.sendSSLPost SocketTimeoutException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (IOException e) &#123; log.error(&quot;调用HttpUtils.sendSSLPost IOException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (Exception e) &#123; log.error(&quot;调用HttpsUtil.sendSSLPost Exception, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; return result.toString(); &#125; private static class TrustAnyTrustManager implements X509TrustManager &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[] &#123;&#125;; &#125; &#125; private static class TrustAnyHostnameVerifier implements HostnameVerifier &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;&#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>access_token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秒杀系统的实现与详解]]></title>
    <url>%2Fmoblog.github.io%2F%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[分析，在做秒杀系统的设计之初，一直在思考如何去设计这个秒杀系统，使之在现有的技术基础和认知范围内，能够做到最好；同时也能充分的利用公司现有的中间件来完成系统的实现。我们都知道，正常去实现一个WEB端的秒杀系统，前端的处理和后端的处理一样重要；前端一般会做CDN，后端一般会做分布式部署，限流，性能优化等等一系列的操作，并完成一些网络的优化，比如IDC多线路（电信、联通、移动）的接入，带宽的升级等等。而由于目前系统前端是基于微信小程序，所以关于前端部分的优化就尽可能都是在代码中完成，CDN这一步就可以免了； 关于秒杀的更多思考，在原有的秒杀架构的基础上新增了新的实现方案原有方案：通过分布式锁的方式控制最终库存不超卖，并控制最终能够进入到下单环节的订单，入到队列中慢慢去消费下单 新增方案“请求进来之后，通过活动开始判断和重复秒杀判断之后，即进入到消息队列，然后在消息的消费端去做库存判断等操作，通过消息队列达到削峰的操作 其实，我觉得两种方案都是可以的，只是具体用在什么样的场景；原有方案更适合流量相对较小的平台，而且整个流程也会更加简单；而新增方案则是许多超大型平台采用的方案，通过消息队列达到削峰的目的；而这两种方案都加了真实能进入的请求限制，通过redis的原子自增来记录请求数，当请求量达到库存的n倍时，后面再进入的请求，则直接返回活动太火爆的提示； 1、架构介绍后端项目是基于SpringCloud+SpringBoot搭建的微服务框架架构 前端在微信小程序商城上 核心支撑组件 服务网关 Zuul 服务注册发现 Eureka+Ribbon 认证授权中心 Spring Security OAuth2、JWTToken 服务框架 Spring MVC/Boot 服务容错 Hystrix 分布式锁 Redis 服务调用 Feign 消息队列 Kafka 文件服务 私有云盘 富文本组件 UEditor 定时任务 xxl-job 配置中心 apollo 2、关于秒杀的场景特点分析 秒杀系统的场景特点 秒杀时大量用户会在同一时间同时进行抢购，网站瞬时访问流量激增； 秒杀一般是访问请求量远远大于库存数量，只有少部分用户能够秒杀成功； 秒杀业务流程比较简单，一般就是下订单操作； 秒杀架构设计理念 限流：鉴于只有少部分用户能够秒杀成功，所以要限制大部分流量，只允许少部分流量进入服务后端（暂未处理）； 削峰：对于秒杀系统瞬时的大量用户涌入，所以在抢购开始会有很高的瞬时峰值。实现削峰的常用方法有利用缓存或者消息中间件等技术； 异步处理：对于高并发系统，采用异步处理模式可以极大地提高系统并发量，异步处理就是削峰的一种实现方式； 内存缓存：秒杀系统最大的瓶颈最终都可能会是数据库的读写，主要体现在的磁盘的I/O，性能会很低，如果能把大部分的业务逻辑都搬到缓存来处理，效率会有极大的提升； 可拓展：如果需要支持更多的用户或者更大的并发，将系统设计为弹性可拓展的，如果流量来了，拓展机器就好； 秒杀设计思路 由于前端是属于小程序端，所以不存在前端部分的访问压力，所以前端的访问压力就无从谈起； 1、秒杀相关的活动页面相关的接口，所有查询能加缓存的，全部添加redis的缓存； 2、活动相关真实库存、锁定库存、限购、下单处理状态等全放redis； 3、当有请求进来时，首先通过redis原子自增的方式记录当前请求数，当请求超过一定量，比如说库存的10倍之后，后面进入的请求则直接返回活动太火爆的响应；而能进入抢购的请求，则首先进入活动ID为粒度的分布式锁，第一步进行用户购买的重复性校验，满足条件进入下一步，否则返回已下单的提示； 4、第二步，判断当前可锁定的库存是否大于购买的数量，满足条件进入下一步，否则返回已售罄的提示； 5、第三步，锁定当前请求的购买库存，从锁定库存中减除，并将下单的请求放入kafka消息队列； 6、第四步，在redis中标记一个polling的key（用于轮询的请求接口判断用户是否下订单成功），在kafka消费端消费完成创建订单之后需要删除该key，并且维护一个活动id+用户id的key，防止重复购买； 7、第五步，消息队列消费，创建订单，创建订单成功则扣减redis中的真实库存，并且删除polling的key。如果下单过程出现异常，则删除限购的key，返还锁定库存，提示用户下单失败； 8、第六步，提供一个轮询接口，给前端在完成抢购动作后，检查最终下订单操作是否成功，主要判断依据是redis中的polling的key的状态； 9、整个流程会将所有到后端的请求拦截的在redis的缓存层面，除了最终能下订单的库存限制订单会与数据库存在交互外，基本上无其他的交互，将数据库I/O压力降到了最低； 关于限流SpringCloud zuul的层面有很好的限流策略，可以防止同一用户的恶意请求行为1234567891011121314151617181920212223 1 zuul: 2 ratelimit: 3 key-prefix: your-prefix #对应用来标识请求的key的前缀 4 enabled: true 5 repository: REDIS #对应存储类型（用来存储统计信息） 6 behind-proxy: true #代理之后 7 default-policy: #可选 - 针对所有的路由配置的策略，除非特别配置了policies 8 limit: 10 #可选 - 每个刷新时间窗口对应的请求数量限制 9 quota: 1000 #可选- 每个刷新时间窗口对应的请求时间限制（秒）10 refresh-interval: 60 # 刷新时间窗口的时间，默认值 (秒)11 type: #可选 限流方式12 - user13 - origin14 - url15 policies:16 myServiceId: #特定的路由17 limit: 10 #可选- 每个刷新时间窗口对应的请求数量限制18 quota: 1000 #可选- 每个刷新时间窗口对应的请求时间限制（秒）19 refresh-interval: 60 # 刷新时间窗口的时间，默认值 (秒)20 type: #可选 限流方式21 - user22 - origin23 - url 关于负载与分流当一个活动的访问量级特别大的时候，可能从域名分发进来的nginx就算是做了高可用，但实际上最终还是单机在线，始终敌不过超大流量的压力时，我们可以考虑域名的多IP映射。也就是说同一个域名下面映射多个外网的IP，再映射到DMZ的多组高可用的nginx服务上，nginx再配置可用的应用服务集群来减缓压力； 这里也顺带介绍redis可以采用redis cluster的分布式实现方案，同时springcloud hystrix 也能有服务容错的效果； 而关于nginx、springboot的tomcat、zuul等一系列参数优化操作对于性能的访问提升也是至关重要； 补充说明一点，即使前端是基于小程序实现，但是活动相关的图片资源都放在自己的云盘服务上，所以活动前活动相关的图片资源上传CDN也是至关重要，否则哪怕是你IDC有1G的流量带宽，也会分分钟被吃完；]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
        <tag>分布式</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot使用gRPC轻松调用远程方法]]></title>
    <url>%2Fmoblog.github.io%2FSpring%20Boot%E4%BD%BF%E7%94%A8gRPC%E8%BD%BB%E6%9D%BE%E8%B0%83%E7%94%A8%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[gRPC简介gRPC 是一个现代开源的高性能 RPC 框架，可以在任何环境下运行。它可以有效地将数据中心内和跨数据中心的服务与可插拔支持进行负载均衡、跟踪、健康检查和认证。它也适用于分布式计算，将不同设备、移动应用程序和浏览器连接到后端服务。 主要使用场景: 在微服务架构中有效地链接多个服务 将移动设备、浏览器客户端连接到后端服务 生成高效的客户端库 核心功能 10种语言的客户端库支持 高效、简单的服务定义框架 基于http/2传输的双向流式传输 可插拔的认证、跟踪、负载均衡和健康检查 Spring Boot 快速集成 gRPC1、获取 spring-boot-starter-grpc 源码 1git clone https://github.com/ChinaSilence/spring-boot-starter-grpc.git 2、安装到本地 Maven 仓库 1mvn install 3、在 Spring Boot 工程中添加依赖 1234567&lt;dependency&gt; &lt;groupId&gt;com.anoyi&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-grpc&lt;/artifactId&gt; &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 4、gRPC 使用说明 4.1 参数配置说明 spring.grpc.enable 是否启用 gRPC 服务端，默认 false spring.grpc.port 监听的端口号 spring.grpc.remote-servers 供客户端调用的服务端列表 4.2 示例：gRPC 服务端，在 application.yml 中添加配置 123spring:grpc: enable: trueport: 6565 4.3 示例：gRPC 客户端，在 application.yml 中添加配置 123spring: grpc: remote-servers: - host: localhostport: 6565 - host: 192.168.0.3port: 6565 4.4 远程服务调用 远程服务调用需要知道远程服务的：地址、端口号、服务类、类方法、方法参数，该 starter 定义了 GrpcRequest 和 GrpcResponse。 1234567891011121314151617181920212223242526public class GrpcRequest &#123; /**- service 类名 */ private String beanName; /** - service 方法名 */ private String methodName; /** - service 方法参数 */ private Object[] args; // 略 setter / getter...&#125;public class GrpcResponse &#123; /**- 响应状态：0 - 成功， 1 - 失败 */ private int status; /** - 返回结果 */ private Object result; // 略 setter / getter...&#125; 4.4.1 示例：服务端提供服务，与单体 Spring Boot 无差别，即单体 Spring Boot 应用可以无缝集成 123456789@Servicepublic class HelloService &#123; public String sayHello() &#123; return &quot;Hello&quot;; &#125; public String say(String words) &#123; return &quot;Hello &quot; + words; &#125;&#125; 4.4.2 【注解方式】示例：客户端调用服务 12345678910import org.springframework.grpc.annotation.GrpcService;/**- 使用 @GprcService 注解定义远程服务，server 指定远程服务名，必须在 application.yml 中定义才能使用 - 方法名 、参数 、 返回结果 必须与服务提供方一致 */@GrpcService(server = &quot;localhost&quot;)public interface HelloService &#123; public String sayHello(); public String say(String words);&#125; 4.4.3 【非注解方式】示例：客户端调用服务 1234567891011121314151617181920212223242526public void test() &#123; // 构建请求体 GrpcRequest grpcRequest = new GrpcRequest(); grpcRequest.setServiceBeanName(&quot;helloService&quot;); // 无参方法调用 grpcRequest.setServiceMethodName(&quot;sayHello&quot;); try &#123; // 此处服务提供方需要在配置文件中定义，否则无法调用 GrpcResponse response = GrpcClient.connect(&quot;localhost&quot;).handle(grpcRequest); if (response.getStatus() == GrpcResponseStatus.SUCCESS.getCode()) &#123; System.out.println(response.getResult()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 有参方法调用 grpcRequest.setServiceMethodName(&quot;say&quot;); Object[] args = &#123; &quot;hello&quot; &#125;; grpcRequest.setArgs(args); try &#123; // 此处服务提供方需要在配置文件中定义，否则无法调用 GrpcResponse response = GrpcClient.connect(&quot;localhost&quot;).handle(grpcRequest); if (response.getStatus() == GrpcResponseStatus.SUCCESS.getCode()) &#123; System.out.println(response.getResult()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 4.4.4 【测试使用】示例：为方便调试，通过原生方式调用远程服务，无需依赖 Spring Boot 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import com.alibaba.fastjson.JSON;import com.anoyi.rpc.CommonServiceGrpc;import com.anoyi.rpc.GrpcService;import io.grpc.ManagedChannel;import io.grpc.ManagedChannelBuilder;import org.springframework.grpc.service.GrpcRequest;import java.util.concurrent.TimeUnit;public class GrpcClient &#123; private final ManagedChannel channel; private final CommonServiceGrpc.CommonServiceBlockingStub blockingStub; public GrpcClient(String host, int port) &#123; this(ManagedChannelBuilder.forAddress(host, port).usePlaintext().build()); &#125; private GrpcClient(ManagedChannel channel) &#123; this.channel = channel; blockingStub = CommonServiceGrpc.newBlockingStub(channel); &#125; public static void main(String[] args) throws Exception &#123; GrpcClient client = new GrpcClient(&quot;localhost&quot;, 6565); try &#123; for (int i = 0; i &lt; 100; i++) &#123; String words = &quot;world - &quot; + i; client.say(words); &#125; &#125; finally &#123; client.shutdown(); &#125; &#125; private void shutdown() throws InterruptedException &#123; channel.shutdown().awaitTermination(5, TimeUnit.SECONDS); &#125; private void say(String words) &#123; GrpcRequest grpcRequest = new GrpcRequest(); grpcRequest.setBeanName(&quot;helloService&quot;); grpcRequest.setMethodName(&quot;say&quot;); Object[] params = &#123; words &#125;; grpcRequest.setArgs(params); System.out.println(&quot;远程调用 &quot; + grpcRequest.getServiceBeanName() + &quot;.&quot; + grpcRequest.getServiceMethodName() + &quot; &quot;); byte[] bytes = ProtobufUtils.serialize(grpcRequest); GrpcService.Request request = GrpcService.Request.newBuilder().setRequest(ByteString.copyFrom(bytes)).build(); GrpcService.Response response = blockingStub.handle(request); System.out.println(&quot;远程调用结果: &quot; + response.getReponse()); &#125;&#125;]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[live2d宠物安装]]></title>
    <url>%2Fmoblog.github.io%2Flive2d%2F</url>
    <content type="text"><![CDATA[Install seperated modelsuse npm install {packagename} The package name is the folder name in packages/ We have:live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install –save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install –save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以太坊 Web3.js 开发基础]]></title>
    <url>%2Fmoblog.github.io%2Fweb3-js%2F</url>
    <content type="text"><![CDATA[简介web3.js 是一个通过RPC 调用 和本地以太坊节点进行通信的js库。web3.js可以与任何暴露了RPC接口的以太坊节点连接。web3中提供了eth对象 - web3.eth来与以太坊区块链进行交互。在github上获得代码安装 Testrpc安装Ethereum客户端来支持JSON RPC API调用开发环境，推荐使用EthereumJS。安装命令：sudo npm install -g ethereumjs-testrpc 启动 testrpc在命令行执行testrpcEthereumJS TestRPC v6.0.3 (ganache-core: 2.0.2) Available Accounts(0) 0x1abb473c627e690c048dbf7a9f9cc54b25dea42a(1) 0xd50fadba656c8f78916f9c1a1b78fd3d35dad0aa(2) 0x69e0159cf8e6fc81e8e71479aea0e8984d7daf48(3) 0x5f1ebce982445a02ff4530f4d53cd09cb2a6addf(4) 0x746f6a0192cf42001ded53a55932a6dff754e143(5) 0x685dcca08e5efc905a300eff68bf2e8a81989966(6) 0x08eed3a1a801be6af543105cb9bfc27b6401c020(7) 0xc8fd99bde94fbfab654c8cffda6047b16306cc07(8) 0xc28e0b677883f809faa1eaf563a5f4b794dcbaeb(9) 0xd02b16bbaa70b2cba4ea173009f2fdf829a8ffba Private Keys(0) d233ec4635ed0fe5c61977c9442d6233c599cd3591107b9a017f7ea6077da3bc(1) a02a88b2c04aed72b55cdd6f6212e1f560dd02767f0a03627fac97b64b64086d(2) 833dd28ab15388ba162862c365313978dabb96d209c311bca7d9a7bfdb2ecb6f(3) 47c7ae2635fed1b4f5e442496fd364cdaa91ae6e950b45f36aa4ac6c172cffb5(4) 4b8ee2ee44eab299cbeff51bbf6fb74572e493409556e728a385dcf9e4dc4f84(5) 50cdb8a14babddcbb79f14ad7b5cc55e95a0b8ce72659eec1c9b8d798ff52369(6) becc6dd7a41564aaf3f2f1711eb102032ace0c4e4b561fc7c922ea92f1a81c5a(7) cc82c2ad095b32bd23e33bc9c3ef6b69ad8b76de07a9e02714760d2fd843efa5(8) 44f9c35f62ffe1aa3b85bb6e557569beb396ced7d5ab8a75345d9a8ab1283bca(9) 3d7ec84ed3253366f744a754ccdc2187d65856c2b264e9fbd651c59896aac229 HD WalletMnemonic: tilt oyster obtain car venture party power exclude fire price senior blueBase HD Path: m/44’/60’/0’/0/{account_index} Listening on localhost:8545 会自动创建10个账户，每个账户默认有100个以太币。安装和和获取web3对象安装npm: npm install web3bower: bower install web3metor: meteor add ethereum:web3vanilla: dist./web3.min.js获得web3实例if (typeof web3 !== ‘undefined’) { web3 = new Web3(web3.currentProvider);} else { // set the provider you want from Web3.providers web3 = new Web3(new Web3.providers.HttpProvider(“http://localhost:8545&quot;));} 使用实例一、账户操作：获取账户web3.eth.getAccounts(function(error, result){ res.send(result) }) 创建新账户web3.eth.accounts.create(); { address: “0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01”, privateKey: “0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709”, signTransaction: function(tx){…}, sign: function(data){…}, encrypt: function(password){…}} web3.eth.accounts.create(‘2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567’); { address: “0xF2CD2AA0c7926743B1D4310b2BC984a0a453c3d4”, privateKey: “0xd7325de5c2c1cf0009fac77d3d04a9c004b038883446b065871bc3e831dcd098”, signTransaction: function(tx){…}, sign: function(data){…}, encrypt: function(password){…}} web3.eth.accounts.create(web3.utils.randomHex(32)); { address: “0xe78150FaCD36E8EB00291e251424a0515AA1FF05”, privateKey: “0xcc505ee6067fba3f6fc2050643379e190e087aeffe5d958ab9f2f3ed3800fa4e”, signTransaction: function(tx){…}, sign: function(data){…}, encrypt: function(password){…}} 使用私钥创建账户web3.eth.accounts.privateKeyToAccount(privateKey);web3.eth.accounts.privateKeyToAccount(‘0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709’); { address: ‘0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01’, privateKey: ‘0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709’, signTransaction: function(tx){…}, sign: function(data){…}, encrypt: function(password){…}} web3.eth.accounts.privateKeyToAccount(‘0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709’); { address: ‘0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01’, privateKey: ‘0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709’, signTransaction: function(tx){…}, sign: function(data){…}, encrypt: function(password){…}} 使用私钥签名一个交易web3.eth.accounts.signTransaction(tx, privateKey [, callback]);web3.eth.accounts.signTransaction({ to: ‘0xF0109fC8DF283027b6285cc889F5aA624EaC1F55’, value: ‘1000000000’, gas: 2000000}, ‘0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318’).then(console.log); { messageHash: ‘0x88cfbd7e51c7a40540b233cf68b62ad1df3e92462f1c6018d6d67eae0f3b08f5’, v: ‘0x25’, r: ‘0xc9cf86333bcb065d140032ecaab5d9281bde80f21b9687b3e94161de42d51895’, s: ‘0x727a108a0b8d101465414033c3f705a9c7b826e596766046ee1183dbc8aeaa68’, rawTransaction: ‘0xf869808504e3b29200831e848094f0109fc8df283027b6285cc889f5aa624eac1f55843b9aca008025a0c9cf86333bcb065d140032ecaab5d9281bde80f21b9687b3e94161de42d51895a0727a108a0b8d101465414033c3f705a9c7b826e596766046ee1183dbc8aeaa68’} web3.eth.accounts.signTransaction({ to: ‘0xF0109fC8DF283027b6285cc889F5aA624EaC1F55’, value: ‘1000000000’, gas: 2000000, gasPrice: ‘234567897654321’, nonce: 0, chainId: 1}, ‘0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318’).then(console.log); { messageHash: ‘0x6893a6ee8df79b0f5d64a180cd1ef35d030f3e296a5361cf04d02ce720d32ec5’, r: ‘0x9ebb6ca057a0535d6186462bc0b465b561c94a295bdb0621fc19208ab149a9c’, s: ‘0x440ffd775ce91a833ab410777204d5341a6f9fa91216a6f3ee2c051fea6a0428’, v: ‘0x25’, rawTransaction: ‘0xf86a8086d55698372431831e848094f0109fc8df283027b6285cc889f5aa624eac1f55843b9aca008025a009ebb6ca057a0535d6186462bc0b465b561c94a295bdb0621fc19208ab149a9ca0440ffd775ce91a833ab410777204d5341a6f9fa91216a6f3ee2c051fea6a0428’} 哈希一个消息web3.eth.accounts.hashMessage(message);web3.eth.accounts.hashMessage(“Hello World”) “0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2” // the below results in the same hashweb3.eth.accounts.hashMessage(web3.utils.utf8ToHex(“Hello World”)) “0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2” sign 给任意一个内容使用私钥签名web3.eth.accounts.sign(data, privateKey);web3.eth.accounts.sign(‘Some data’, ‘0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318’); { message: ‘Some data’, messageHash: ‘0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655’, v: ‘0x1c’, r: ‘0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd’, s: ‘0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029’, signature: ‘0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c’} 使用web3.eth.personal 新建账户web3.eth.personal.newAccount(password, [callback])web3.eth.personal.newAccount(‘!@superpassword’).then(console.log); ‘0x1234567891011121314151617181920212223456’ 获得账户余额web3.eth.getBalance(‘0xe70c4835b29e2fd35bd3f60c0a76413f70f17115’).then(function(balance){ console.log(‘balance:’,balance) balance = new BigNumber(balance) console.log(‘balance:’,balance)}) 这里使用了BigNumber.js 处理余额显示，参考我另一片博文。utils工具函数web3.utils.toHex 将任何值转为HEX 16进制String|Number|Object|Array|BigNumber - 需要转化为HEX的值。如果是一个对象或数组类型，将会先用JSON.stringify1进行转换成字符串。如果传入的是BigNumber2，则将得到对应的Number的HEXvar str = “abcABC”;var obj = {abc: ‘ABC’};var bignumber = new BigNumber(‘12345678901234567890’); var hstr = web3.utils.toHex(str);var hobj = web3.utils.toHex(obj);var hbg = web3.utils.toHex(bignumber); console.log(“Hex of Sring:” + hstr);console.log(“Hex of Object:” + hobj);console.log(“Hex of BigNumber:” + hbg); web3.utils.isHex(hex) 判断输入是不是16进制web3.utils.isHex(‘0xc1912’); 判断输入是不是一个地址web3.utils.isAddress(‘0xc1912fee45d61c87cc5ea59dae31190fffff232d’); 把金额单位换成weiweb3.utils.toWei(number [, unit])web3.utils.toWei(‘1’, ‘ether’); “1000000000000000000” web3.utils.toWei(‘1’, ‘finney’); “1000000000000000” web3.utils.toWei(‘1’, ‘szabo’); “1000000000000” web3.utils.toWei(‘1’, ‘shannon’);/&gt; “1000000000” 把单位为wei的以太币换成 etherweb3.utils.fromWei(number [, unit])web3.utils.fromWei(‘1’, ‘ether’); “0.000000000000000001” web3.utils.fromWei(‘1’, ‘finney’); “0.000000000000001” web3.utils.fromWei(‘1’, ‘szabo’); “0.000000000001” web3.utils.fromWei(‘1’, ‘shannon’); “0.000000001” 判断给定的数据是否是 BigNumberweb3.utils.isBigNumber(bignumber)var number = new BigNumber(10);web3.utils.isBigNumber(number); sha3算法// web3.utils.sha3(string)// web3.utils.keccak256(string) // ALIASweb3.utils.sha3(‘234’); // taken as string “0xc1912fee45d61c87cc5ea59dae311904cd86b84fee17cc96966216f811ce6a79” web3.utils.sha3(new BN(‘234’)); “0xbc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a” web3.utils.sha3(234); null // can’t calculate the has of a number web3.utils.sha3(0xea); // same as above, just the HEX representation of the number null web3.utils.sha3(‘0xea’); // will be converted to a byte array first, and then hashed “0x2f20677459120677484f7104c76deb6846a2c071f9b3152c103bb12cd54d1a4a” [在github上获得代码] https://github.com/cooleye/web3tutorial 作者：孔德健链接：https://www.jianshu.com/p/f3f36447546e來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>web3js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next 内嵌标签demo]]></title>
    <url>%2Fmoblog.github.io%2Fmy-princess%2F</url>
    <content type="text"><![CDATA[blah blah blah blah blah blah blah blah blah 1 2 3 4 5 6 《告白气球》]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git操作命令]]></title>
    <url>%2Fmoblog.github.io%2Fgit%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git tag 给当前分支打标签原文已经找不到出处，重新整理格式，仅作个人收藏！ 标签(Tag)可以针对某一时间点的版本做标记，常用于版本发布。列出tag$ git tag # 在控制台打印出当前仓库的所有tag$ git tag -l ‘v0.1.*’ # 搜索符合模式的Tag打taggit tag分为两种类型：轻量tag和附注tag。轻量tag是指向提交对象的引用，附注Tag则是仓库中的一个独立对象。建议使用附注Tag。 创建轻量Tag$ git tag v0.1.2-light创建附注Tag$ git tag -a v0.1.2 -m “0.1.2版本”创建轻量Tag不需要传递参数，直接指定Tag名称即可。 创建附注Tag时，参数a即annotated的缩写，指定Tag类型，后附Tag名。参数m指定Tag说明，说明信息会保存在Tag对象中。 切换到Tag与切换分支命令相同，用git checkout [tagname] 查看Tag信息用git show命令可以查看Tag的版本信息： $ git show v0.1.2删除Tag误打或需要修改Tag时，需要先将Tag删除，再打新Tag。 $ git tag -d v0.1.2 # 删除Tag参数d即delete的缩写，意为删除其后指定的Tag。 给指定的commit打Tag打Tag不必要在head之上，也可在之前的版本上打，这需要你知道某个提交对象的校验和（通过git log获取）。 补打Tag $ git tag -a v0.1.1 9fbc3d0Tag推送到服务器通常的git push不会将Tag对象提交到git服务器，我们需要进行显式的操作： $ git push origin v0.1.2 # 将v0.1.2 Tag提交到git服务器$ git push origin –-tags # 将本地所有Tag一次性提交到git服务器注意：如果想看之前某个Tag状态下的文件，可以这样操作 1.git tag 查看当前分支下的Tag 2.git checkout v0.21 此时会指向打v0.21 Tag时的代码状态，（但现在处于一个空的分支上） cat test.txt 查看某个文件]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 命令]]></title>
    <url>%2Fmoblog.github.io%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment #hh]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
