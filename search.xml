<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mall]]></title>
    <url>%2Fmoblog.github.io%2FopenCoding%2FopenCoding%2F</url>
    <content type="text"><![CDATA[说明 基于SpringBoot+MyBatis的电商系统，包括前台商城系统及后台管理系统。 前言mall项目致力于打造一个完整的电商系统，采用现阶段流行技术实现。 项目介绍mall项目是一套电商系统，包括前台商城系统及后台管理系统，基于SpringBoot+MyBatis实现。前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。 项目演示 后台管理系统 前端项目mall-admin-web地址：https://github.com/macrozheng/mall-admin-web 项目演示地址： http://39.98.190.128/index.html 前台商城系统 前端项目mall-app-web地址：敬请期待…… 项目演示地址：http://39.98.190.128/mall-app/mainpage.html 组织结构123456mall├── mall-mbg -- MyBatisGenerator生成的数据库操作代码├── mall-admin -- 后台商城管理系统接口├── mall-search -- 基于Elasticsearch的商品搜索系统├── mall-portal -- 前台商城系统接口└── mall-demo -- 框架搭建时的测试代码 技术选型后端技术 技术 说明 官网 Spring Boot 容器+MVC框架 https://spring.io/projects/spring-boot Spring Security 认证和授权框架 https://spring.io/projects/spring-security MyBatis ORM框架 http://www.mybatis.org/mybatis-3/zh/index.html MyBatisGenerator 数据层代码生成 http://www.mybatis.org/generator/index.html PageHelper MyBatis物理分页插件 http://git.oschina.net/free/Mybatis_PageHelper Swagger-UI 文档生产工具 https://github.com/swagger-api/swagger-ui Hibernator-Validator 验证框架 http://hibernate.org/validator/ Elasticsearch 搜索引擎 https://github.com/elastic/elasticsearch RabbitMq 消息队列 https://www.rabbitmq.com/ Redis 分布式缓存 https://redis.io/ MongoDb NoSql数据库 https://www.mongodb.com/ Docker 应用容器引擎 https://www.docker.com/ Druid 数据库连接池 https://github.com/alibaba/druid OSS 对象存储 https://github.com/aliyun/aliyun-oss-java-sdk JWT JWT登录支持 https://github.com/jwtk/jjwt LogStash 日志收集 https://github.com/logstash/logstash-logback-encoder Lombok 简化对象封装工具 https://github.com/rzwitserloot/lombok 前端技术 技术 说明 官网 Vue 前端框架 https://vuejs.org/ Vue-router 路由框架 https://router.vuejs.org/ Vuex 全局状态管理框架 https://vuex.vuejs.org/ Element 前端UI框架 https://element.eleme.io/ Axios 前端HTTP框架 https://github.com/axios/axios v-charts 基于Echarts的图表框架 https://v-charts.js.org/ Js-cookie cookie管理工具 https://github.com/js-cookie/js-cookie nprogress 进度条控件 https://github.com/rstacruz/nprogress 架构图系统架构图 业务架构图 模块介绍后台管理系统 mall-admin 商品管理：功能结构图-商品.jpg 订单管理：功能结构图-订单.jpg 促销管理：功能结构图-促销.jpg 内容管理：功能结构图-内容.jpg 用户管理：功能结构图-用户.jpg 前台商城系统 mall-portal功能结构图-前台.jpg 开发进度 环境搭建开发工具 工具 说明 官网 IDEA 开发IDE https://www.jetbrains.com/idea/download RedisDesktop redis客户端连接工具 https://redisdesktop.com/download Robomongo mongo客户端连接工具 https://robomongo.org/download SwitchHosts 本地host管理 https://oldj.github.io/SwitchHosts/ X-shell Linux远程连接工具 http://www.netsarang.com/download/software.html Navicat 数据库连接工具 http://www.formysql.com/xiazai.html PowerDesigner 数据库设计工具 http://powerdesigner.de/ Axure 原型设计工具 https://www.axure.com/ MindMaster 思维导图设计工具 http://www.edrawsoft.cn/mindmaster ScreenToGif gif录制工具 https://www.screentogif.com/ ProcessOn 流程图绘制工具 https://www.processon.com/ PicPick 屏幕取色工具 https://picpick.app/zh/ 开发环境 工具 版本号 下载 JDK 1.8 https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html Mysql 5.7 https://www.mysql.com/ Redis 3.2 https://redis.io/download Elasticsearch 2.4 https://www.elastic.co/downloads MongoDb 3.2 https://www.mongodb.com/download-center RabbitMq 5.25 http://www.rabbitmq.com/download.html nginx 1.10 http://nginx.org/en/download.html 搭建步骤 本地环境搭建 本地安装开发环境中的所有工具并启动，具体参考deploy-windows.md; 克隆源代码到本地，使用IDEA或Eclipse打开，并完成编译; 在mysql中新建mall数据库，导入document/sql下的mall.sql文件； 启动mall-admin项目：直接运行com.macro.mall.MallAdminApplication的main方法即可，接口文档地址：http://localhost:8080/swagger-ui.html; 启动mall-search项目：直接运行com.macro.mall.search.MallSearchApplication的main方法即可，接口文档地址：http://localhost:8081/swagger-ui.html; 启动mall-portal项目：直接运行com.macro.mall.portal.MallPortalApplication的main方法即可，接口文档地址：http://localhost:8085/swagger-ui.html; 克隆mall-admin-web项目，并导入到IDEA中并完成编译传送门; 运行命令：npm run dev,访问地址：http://localhost:8090 即可打开后台管理系统页面; ELK日志收集系统的搭建：参考elk.md。 docker环境部署 在VirtualBox或其他环境中安装CenterOs7.2; 配置本地host:参考host.txt,将ip地址改为虚拟机的ip地址; 使用maven构建mall-admin、mall-search、mall-portal的docker镜像，参考docker.md中的使用maven构建Docker镜像; 部署步骤参考docker-deploy.md进行部署。 参考资料 Spring实战（第4版） Spring Boot实战 Spring Cloud微服务实战 Spring Cloud与Docker微服务架构实战 Spring Data实战 MyBatis从入门到精通 深入浅出MySQL 循序渐进Linux（第2版） Elasticsearch 技术解析与实战 MongoDB实战(第二版) Kubernetes权威指南 许可证MIT Copyright (c) 2018-2019 macrozheng]]></content>
      <categories>
        <category>电商系统</category>
      </categories>
      <tags>
        <tag>后台</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曾国藩语录]]></title>
    <url>%2Fmoblog.github.io%2Fzgf-say%2Fzgf-say%2F</url>
    <content type="text"><![CDATA[曾国藩：男人要想有出息，做到这六点，钱必定来追你！ 第一戒：久利之事勿为，众争之地勿往前半句是指：做人不可贪求过多！日中则移，月满则亏，物盛则衰世界上没有一劳永逸的事情，长久获利的事都是表面，背后隐藏危机，所以在利益面前头脑一定要清醒。后半句有两层意思：一是众人争执、争斗的地方你不要去，容易惹麻烦或者招致祸患。二是大家都去争抢的利益，你就不要去争抢了，因为那肯定是薄利。 第二戒：勿以小恶弃人大美，勿以小怨忘人大恩人无完人，所以我们不能因为别人的缺点就忽视了优点，也不要因为小小的恩怨就忽略了别人的大恩。人生难免会有做错事的时候，所以不要因为别人的一点小过失，一点道德上的小瑕疵，一点小恩怨，就全盘否定别人的好，忘记别人的恩情。 第三戒：说人之短乃护己之短，夸己之长乃忌人之长经常说别人短处的人，经常夸耀自己长处的人，可以说是“存心不厚，识量太狭。”俗话说，“打人不打脸，揭人不揭短。”经常谈论别人的短处，夸耀自己的长处，不仅是情商低的表现，也必然给自己招来怨恨，埋下祸乱的种子。 第四戒：利可共而不可独，谋可寡而不可众曹操能够“挟天子以令诸侯”，却终其一生不敢篡汉自立，他们都是怕成为众矢之的。所以，面对利益，一定要权衡取舍之道。《战国策》上说：“论至德者不和于俗，成大功者不谋于众。”谋求特别重大的事情，不必与众人商量。因为谋求大事的人，自己必定有非同一般的眼光、心胸与气度，自己看准了，去做就是了，如果和别人商量，反倒麻烦。人多七嘴八舌，会动摇你的意志，也会破坏你的信心和情绪。 第五戒：古今之庸人，皆以一惰字致败，天下古今之才人，皆以一傲字致败庸人，就是普通人，一般的人。对于一般的人来说，没有什么才气，只有勤奋工作才能成就事业，所以最忌讳一个“懒”字。曾国藩是勤劳的好例子，他其实并不聪明，但是却能以“勤”成就大学问和大事业，可以说正是普通人的榜样。而那些有才的人呢，虽然可凭才气走捷径，更容易成功，但也容易孤傲自大，故步自封，不肯向别人学习，这也是容易失败的。如项羽、李自成等，占尽天时地利，却因为骄傲而败亡。 第六戒：凡办大事，以识为主，以才为辅；凡成大事，人谋居半，天意居半所谓谋事在人，成事在天；曾国藩明确告诉我们，办大事要以“识”为主，才气、才能不过是辅助罢了。所以恃才傲物的人，往往难以成就大事，当然这里的“识”，不单单指知识，更指的是经验和见识。而“人谋居半，天意居半。”则是说，我们无论做什么事情，都要抱着“尽人事以听天命”的态度。不要因为有自己不能左右的的因素就不去努力，更不能因为自己努力了，最终却失败了而去怨天尤人。纵观人生，道阻且长，有许多机遇也有许多祸患。所以人生当戒则戒，方能无忧！——编辑 袭人]]></content>
      <categories>
        <category>曾国藩语录</category>
      </categories>
      <tags>
        <tag>曾国藩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HoorayOS_mini]]></title>
    <url>%2Fmoblog.github.io%2FHoorayOS-mini%2F</url>
    <content type="text"><![CDATA[===== 桌面应用数据 =====桌面通过读取data.js里的json数据显示桌面应用，其data.js可替换成后端输出，打开hros.app.js，找到17行，把data.js的路径替换成后端输出桌面json数据的地址即可。===== 应用结构参数说明 ===== 源码地址：https://github.com/QingShaoXi/Blog_Album/tree/master/HoorayOS_miniapp应用 id : 0, //应用id，确保该id唯一不重复，因为打开、关闭等操作都是根据这个唯一id来查找应用的title : “我的博客”, //应用名称type : “app”, //应用类型，分别有app、widget可选，app为窗口应用，widget为挂件应用icon : “img/ui/system-shapes.png”, //应用图标url : “http://www.cnblogs.com/hooray&quot;, //应用地址width : 1000, //应用显示宽度height : 500, //应用显示高度left : 100, //距离页面左部偏移量，不设置默认水平居中top : 100, //距离页面顶部偏移量，不设置默认垂直居中isresize : true, //应用是否可以拉伸isopenmax : false, //应用是否打开自动最大化状态isflash : false //应用是否为flash应用 widget应用 id : 0, //应用id，确保该id唯一不重复，因为打开、关闭等操作都是根据这个唯一id来查找应用的title : “我的博客”, //应用名称type : “widget”, //应用类型，分别有app、widget可选，app为窗口应用，widget为挂件应用icon : “img/ui/system-shapes.png”, //应用图标url : “http://www.cnblogs.com/hooray&quot;, //应用地址width : 1000, //应用显示宽度height : 500, //应用显示高度right : 100, //距离页面右部偏移量，不设置默认为0top : 100 //距离页面顶部偏移量，不设置默认为0 ===== 如何更换壁纸 ===== 打开index.html，找到：HROS.CONFIG.wallpaper = ‘img/wallpaper/wallpaper.jpg’;将后面的地址替换成其它壁纸图片链接即可 ===== 如何创建临时窗口和挂件 ===== 创建一个临时窗口，多次调用会多次创建，窗口不唯一 HROS.window.createTemp({title:’百度’,url:’http://hoorayos.com&#39;,width:800,height:400,left:100,top:100,isresize:false,isopenmax:false,isflash:false}); 创建一个临时挂件，多次调用会多次创建，窗口不唯一 HROS.widget.createTemp({url:’http://hoorayos.com&#39;,width:800,height:400,right:100,top:100}); 创建一个临时窗口，多次调用不会重复创建，窗口唯一，需要在参数里加上appid属性，内容随便填写，但确保appid唯一，以免与系统窗口重复参数说明：title：标题，url：网址，width：窗口宽度，height：窗口高度，left：挂件距离页面左部偏移量(可不填，默认0)，top：挂件距离页面顶部偏移量(可不填，默认0)，isresize：窗口是否可以拉伸(可不填，默认false)，isopenmax：窗口打开是否默认最大化(可不填，默认false)，isflash：窗口内是否为flash应用(可不填，默认false) HROS.window.createTemp({appid:’window_baidu’,title:’百度’,url:’hoorayos.com’,width:800,height:400,left:100,top:100,isresize:false,isopenmax:false,isflash:false}); 创建一个临时挂件，多次调用不会重复创建，窗口唯一，需要在参数里加上appid属性，内容随便填写，但确保appid唯一，以免与系统挂件重复参数说明：url：网址，width：窗口宽度，height：窗口高度，right：挂件距离页面左部偏移量(可不填，默认0)，top：挂件距离页面顶部偏移量(可不填，默认0) HROS.widget.createTemp({appid:’widget_baidu’,url:’hoorayos.com’,width:800,height:400,right:100,top:100});]]></content>
      <categories>
        <category>前端UI</category>
      </categories>
      <tags>
        <tag>仿window桌面webUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序接口调用凭证]]></title>
    <url>%2Fmoblog.github.io%2Faccess-token%2F</url>
    <content type="text"><![CDATA[请求地址1GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET java后端12345678910private static String tokenUrl = &quot;https://api.weixin.qq.com/cgi-bin/token&quot;;StringBuffer buffer = new StringBuffer(&quot;grant_type=client_credential&quot;);buffer.append(&quot;&amp;appid=&quot;+defaultConfig.getAppid());buffer.append(&quot;&amp;secret=&quot;+defaultConfig.getSecret());String result = HttpUtils.sendGet(tokenUrl,buffer.toString());JSONObject obj = JSONObject.parseObject(result);if(obj.get(&quot;errcode&quot;) != null)&#123; throw new BadRequestException(&quot;二维码生成异常&quot;);&#125; http请求工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310package com.zerocat.core.utils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.net.ssl.*;import java.io.*;import java.net.ConnectException;import java.net.SocketTimeoutException;import java.net.URL;import java.net.URLConnection;import java.security.cert.X509Certificate;import java.util.Iterator;import java.util.Map;/** * 通用http发送方法 * * @author zwx */public class HttpUtils&#123; private static final Logger log = LoggerFactory.getLogger(HttpUtils.class); /** * 向指定 URL 发送GET方法的请求 * * @param url 发送请求的 URL * @param param 请求参数，请求参数应该是 name1=value1&amp;name2=value2 的形式。 * @return 所代表远程资源的响应结果 */ public static String sendGet(String url, String param) &#123; StringBuilder result = new StringBuilder(); BufferedReader in = null; try &#123; String urlNameString = url + &quot;?&quot; + param; log.info(&quot;sendGet - &#123;&#125;&quot;, urlNameString); URL realUrl = new URL(urlNameString); URLConnection connection = realUrl.openConnection(); connection.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); connection.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); connection.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;); connection.connect(); in = new BufferedReader(new InputStreamReader(connection.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; result.append(line); &#125; log.info(&quot;recv - &#123;&#125;&quot;, result); &#125; catch (ConnectException e) &#123; log.error(&quot;调用HttpUtils.sendGet ConnectException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (SocketTimeoutException e) &#123; log.error(&quot;调用HttpUtils.sendGet SocketTimeoutException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (IOException e) &#123; log.error(&quot;调用HttpUtils.sendGet IOException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (Exception e) &#123; log.error(&quot;调用HttpsUtil.sendGet Exception, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; finally &#123; try &#123; if (in != null) &#123; in.close(); &#125; &#125; catch (Exception ex) &#123; log.error(&quot;调用in.close Exception, url=&quot; + url + &quot;,param=&quot; + param, ex.getMessage()); &#125; &#125; return result.toString(); &#125; /** * 向指定 URL 发送POST方法的请求 * * @param url 发送请求的 URL * @param param 请求参数，请求参数应该是 name1=value1&amp;name2=value2 的形式。 * @return 所代表远程资源的响应结果 */ public static String sendPost(String url, String param) &#123; PrintWriter out = null; BufferedReader in = null; StringBuilder result = new StringBuilder(); try &#123; String urlNameString = url + &quot;?&quot; + param; log.info(&quot;sendPost - &#123;&#125;&quot;, urlNameString); URL realUrl = new URL(urlNameString); URLConnection conn = realUrl.openConnection(); conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;); conn.setRequestProperty(&quot;Accept-Charset&quot;, &quot;utf-8&quot;); conn.setRequestProperty(&quot;contentType&quot;, &quot;utf-8&quot;); conn.setDoOutput(true); conn.setDoInput(true); out = new PrintWriter(conn.getOutputStream()); out.print(param); out.flush(); in = new BufferedReader(new InputStreamReader(conn.getInputStream(), &quot;utf-8&quot;)); String line; while ((line = in.readLine()) != null) &#123; result.append(line); &#125; log.info(&quot;recv - &#123;&#125;&quot;, result); &#125; catch (ConnectException e) &#123; log.error(&quot;调用HttpUtils.sendPost ConnectException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (SocketTimeoutException e) &#123; log.error(&quot;调用HttpUtils.sendPost SocketTimeoutException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (IOException e) &#123; log.error(&quot;调用HttpUtils.sendPost IOException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (Exception e) &#123; log.error(&quot;调用HttpsUtil.sendPost Exception, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException ex) &#123; log.error(&quot;调用in.close Exception, url=&quot; + url + &quot;,param=&quot; + param, ex.getMessage()); &#125; &#125; return result.toString(); &#125; /** * 向指定 URL 发送POST方法的请求 * * @param url 发送请求的 URL * @param paramMap 请求参数 * @return 所代表远程资源的响应结果 */ public static String sendPost(String url, Map&lt;String, ?&gt; paramMap) &#123; PrintWriter out = null; BufferedReader in = null; String result = &quot;&quot;; String param = &quot;&quot;; Iterator&lt;String&gt; it = paramMap.keySet().iterator(); while (it.hasNext()) &#123; String key = it.next(); param += key + &quot;=&quot; + paramMap.get(key) + &quot;&amp;&quot;; &#125; try &#123; URL realUrl = new URL(url); // 打开和URL之间的连接 URLConnection conn = realUrl.openConnection(); // 设置通用的请求属性 conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;Accept-Charset&quot;, &quot;utf-8&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;); // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); // 获取URLConnection对象对应的输出流 out = new PrintWriter(conn.getOutputStream()); // 发送请求参数 out.print(param); // flush输出流的缓冲 out.flush(); // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader(new InputStreamReader(conn.getInputStream(), &quot;UTF-8&quot;)); String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); &#125; //使用finally块来关闭输出流、输入流 finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; return result; &#125; @SuppressWarnings(&quot;deprecation&quot;) public static String sendSSLPost(String url, String param) &#123; StringBuilder result = new StringBuilder(); String urlNameString = url + &quot;?&quot; + param; try &#123; log.info(&quot;sendSSLPost - &#123;&#125;&quot;, urlNameString); SSLContext sc = SSLContext.getInstance(&quot;SSL&quot;); sc.init(null, new TrustManager[] &#123; new TrustAnyTrustManager() &#125;, new java.security.SecureRandom()); URL console = new URL(urlNameString); HttpsURLConnection conn = (HttpsURLConnection) console.openConnection(); conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;); conn.setRequestProperty(&quot;Accept-Charset&quot;, &quot;utf-8&quot;); conn.setRequestProperty(&quot;contentType&quot;, &quot;utf-8&quot;); conn.setDoOutput(true); conn.setDoInput(true); conn.setSSLSocketFactory(sc.getSocketFactory()); conn.setHostnameVerifier(new TrustAnyHostnameVerifier()); conn.connect(); InputStream is = conn.getInputStream(); DataInputStream indata = new DataInputStream(is); String ret = &quot;&quot;; while (ret != null) &#123; ret = indata.readLine(); if (ret != null &amp;&amp; !ret.trim().equals(&quot;&quot;)) &#123; result.append(new String(ret.getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;)); &#125; &#125; log.info(&quot;recv - &#123;&#125;&quot;, result); conn.disconnect(); indata.close(); &#125; catch (ConnectException e) &#123; log.error(&quot;调用HttpUtils.sendSSLPost ConnectException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (SocketTimeoutException e) &#123; log.error(&quot;调用HttpUtils.sendSSLPost SocketTimeoutException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (IOException e) &#123; log.error(&quot;调用HttpUtils.sendSSLPost IOException, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; catch (Exception e) &#123; log.error(&quot;调用HttpsUtil.sendSSLPost Exception, url=&quot; + url + &quot;,param=&quot; + param, e.getMessage()); &#125; return result.toString(); &#125; private static class TrustAnyTrustManager implements X509TrustManager &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[] &#123;&#125;; &#125; &#125; private static class TrustAnyHostnameVerifier implements HostnameVerifier &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;&#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>access_token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秒杀系统的实现与详解]]></title>
    <url>%2Fmoblog.github.io%2F%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[分析，在做秒杀系统的设计之初，一直在思考如何去设计这个秒杀系统，使之在现有的技术基础和认知范围内，能够做到最好；同时也能充分的利用公司现有的中间件来完成系统的实现。我们都知道，正常去实现一个WEB端的秒杀系统，前端的处理和后端的处理一样重要；前端一般会做CDN，后端一般会做分布式部署，限流，性能优化等等一系列的操作，并完成一些网络的优化，比如IDC多线路（电信、联通、移动）的接入，带宽的升级等等。而由于目前系统前端是基于微信小程序，所以关于前端部分的优化就尽可能都是在代码中完成，CDN这一步就可以免了； 关于秒杀的更多思考，在原有的秒杀架构的基础上新增了新的实现方案原有方案：通过分布式锁的方式控制最终库存不超卖，并控制最终能够进入到下单环节的订单，入到队列中慢慢去消费下单 新增方案“请求进来之后，通过活动开始判断和重复秒杀判断之后，即进入到消息队列，然后在消息的消费端去做库存判断等操作，通过消息队列达到削峰的操作 其实，我觉得两种方案都是可以的，只是具体用在什么样的场景；原有方案更适合流量相对较小的平台，而且整个流程也会更加简单；而新增方案则是许多超大型平台采用的方案，通过消息队列达到削峰的目的；而这两种方案都加了真实能进入的请求限制，通过redis的原子自增来记录请求数，当请求量达到库存的n倍时，后面再进入的请求，则直接返回活动太火爆的提示； 1、架构介绍后端项目是基于SpringCloud+SpringBoot搭建的微服务框架架构 前端在微信小程序商城上 核心支撑组件 服务网关 Zuul 服务注册发现 Eureka+Ribbon 认证授权中心 Spring Security OAuth2、JWTToken 服务框架 Spring MVC/Boot 服务容错 Hystrix 分布式锁 Redis 服务调用 Feign 消息队列 Kafka 文件服务 私有云盘 富文本组件 UEditor 定时任务 xxl-job 配置中心 apollo 2、关于秒杀的场景特点分析 秒杀系统的场景特点 秒杀时大量用户会在同一时间同时进行抢购，网站瞬时访问流量激增； 秒杀一般是访问请求量远远大于库存数量，只有少部分用户能够秒杀成功； 秒杀业务流程比较简单，一般就是下订单操作； 秒杀架构设计理念 限流：鉴于只有少部分用户能够秒杀成功，所以要限制大部分流量，只允许少部分流量进入服务后端（暂未处理）； 削峰：对于秒杀系统瞬时的大量用户涌入，所以在抢购开始会有很高的瞬时峰值。实现削峰的常用方法有利用缓存或者消息中间件等技术； 异步处理：对于高并发系统，采用异步处理模式可以极大地提高系统并发量，异步处理就是削峰的一种实现方式； 内存缓存：秒杀系统最大的瓶颈最终都可能会是数据库的读写，主要体现在的磁盘的I/O，性能会很低，如果能把大部分的业务逻辑都搬到缓存来处理，效率会有极大的提升； 可拓展：如果需要支持更多的用户或者更大的并发，将系统设计为弹性可拓展的，如果流量来了，拓展机器就好； 秒杀设计思路 由于前端是属于小程序端，所以不存在前端部分的访问压力，所以前端的访问压力就无从谈起； 1、秒杀相关的活动页面相关的接口，所有查询能加缓存的，全部添加redis的缓存； 2、活动相关真实库存、锁定库存、限购、下单处理状态等全放redis； 3、当有请求进来时，首先通过redis原子自增的方式记录当前请求数，当请求超过一定量，比如说库存的10倍之后，后面进入的请求则直接返回活动太火爆的响应；而能进入抢购的请求，则首先进入活动ID为粒度的分布式锁，第一步进行用户购买的重复性校验，满足条件进入下一步，否则返回已下单的提示； 4、第二步，判断当前可锁定的库存是否大于购买的数量，满足条件进入下一步，否则返回已售罄的提示； 5、第三步，锁定当前请求的购买库存，从锁定库存中减除，并将下单的请求放入kafka消息队列； 6、第四步，在redis中标记一个polling的key（用于轮询的请求接口判断用户是否下订单成功），在kafka消费端消费完成创建订单之后需要删除该key，并且维护一个活动id+用户id的key，防止重复购买； 7、第五步，消息队列消费，创建订单，创建订单成功则扣减redis中的真实库存，并且删除polling的key。如果下单过程出现异常，则删除限购的key，返还锁定库存，提示用户下单失败； 8、第六步，提供一个轮询接口，给前端在完成抢购动作后，检查最终下订单操作是否成功，主要判断依据是redis中的polling的key的状态； 9、整个流程会将所有到后端的请求拦截的在redis的缓存层面，除了最终能下订单的库存限制订单会与数据库存在交互外，基本上无其他的交互，将数据库I/O压力降到了最低； 关于限流SpringCloud zuul的层面有很好的限流策略，可以防止同一用户的恶意请求行为1234567891011121314151617181920212223 1 zuul: 2 ratelimit: 3 key-prefix: your-prefix #对应用来标识请求的key的前缀 4 enabled: true 5 repository: REDIS #对应存储类型（用来存储统计信息） 6 behind-proxy: true #代理之后 7 default-policy: #可选 - 针对所有的路由配置的策略，除非特别配置了policies 8 limit: 10 #可选 - 每个刷新时间窗口对应的请求数量限制 9 quota: 1000 #可选- 每个刷新时间窗口对应的请求时间限制（秒）10 refresh-interval: 60 # 刷新时间窗口的时间，默认值 (秒)11 type: #可选 限流方式12 - user13 - origin14 - url15 policies:16 myServiceId: #特定的路由17 limit: 10 #可选- 每个刷新时间窗口对应的请求数量限制18 quota: 1000 #可选- 每个刷新时间窗口对应的请求时间限制（秒）19 refresh-interval: 60 # 刷新时间窗口的时间，默认值 (秒)20 type: #可选 限流方式21 - user22 - origin23 - url 关于负载与分流当一个活动的访问量级特别大的时候，可能从域名分发进来的nginx就算是做了高可用，但实际上最终还是单机在线，始终敌不过超大流量的压力时，我们可以考虑域名的多IP映射。也就是说同一个域名下面映射多个外网的IP，再映射到DMZ的多组高可用的nginx服务上，nginx再配置可用的应用服务集群来减缓压力； 这里也顺带介绍redis可以采用redis cluster的分布式实现方案，同时springcloud hystrix 也能有服务容错的效果； 而关于nginx、springboot的tomcat、zuul等一系列参数优化操作对于性能的访问提升也是至关重要； 补充说明一点，即使前端是基于小程序实现，但是活动相关的图片资源都放在自己的云盘服务上，所以活动前活动相关的图片资源上传CDN也是至关重要，否则哪怕是你IDC有1G的流量带宽，也会分分钟被吃完；]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
        <tag>分布式</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot使用gRPC轻松调用远程方法]]></title>
    <url>%2Fmoblog.github.io%2FSpring%20Boot%E4%BD%BF%E7%94%A8gRPC%E8%BD%BB%E6%9D%BE%E8%B0%83%E7%94%A8%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[gRPC简介gRPC 是一个现代开源的高性能 RPC 框架，可以在任何环境下运行。它可以有效地将数据中心内和跨数据中心的服务与可插拔支持进行负载均衡、跟踪、健康检查和认证。它也适用于分布式计算，将不同设备、移动应用程序和浏览器连接到后端服务。 主要使用场景: 在微服务架构中有效地链接多个服务 将移动设备、浏览器客户端连接到后端服务 生成高效的客户端库 核心功能 10种语言的客户端库支持 高效、简单的服务定义框架 基于http/2传输的双向流式传输 可插拔的认证、跟踪、负载均衡和健康检查 Spring Boot 快速集成 gRPC1、获取 spring-boot-starter-grpc 源码 1git clone https://github.com/ChinaSilence/spring-boot-starter-grpc.git 2、安装到本地 Maven 仓库 1mvn install 3、在 Spring Boot 工程中添加依赖 1234567&lt;dependency&gt; &lt;groupId&gt;com.anoyi&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-grpc&lt;/artifactId&gt; &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 4、gRPC 使用说明 4.1 参数配置说明 spring.grpc.enable 是否启用 gRPC 服务端，默认 false spring.grpc.port 监听的端口号 spring.grpc.remote-servers 供客户端调用的服务端列表 4.2 示例：gRPC 服务端，在 application.yml 中添加配置 123spring:grpc: enable: trueport: 6565 4.3 示例：gRPC 客户端，在 application.yml 中添加配置 123spring: grpc: remote-servers: - host: localhostport: 6565 - host: 192.168.0.3port: 6565 4.4 远程服务调用 远程服务调用需要知道远程服务的：地址、端口号、服务类、类方法、方法参数，该 starter 定义了 GrpcRequest 和 GrpcResponse。 1234567891011121314151617181920212223242526public class GrpcRequest &#123; /**- service 类名 */ private String beanName; /** - service 方法名 */ private String methodName; /** - service 方法参数 */ private Object[] args; // 略 setter / getter...&#125;public class GrpcResponse &#123; /**- 响应状态：0 - 成功， 1 - 失败 */ private int status; /** - 返回结果 */ private Object result; // 略 setter / getter...&#125; 4.4.1 示例：服务端提供服务，与单体 Spring Boot 无差别，即单体 Spring Boot 应用可以无缝集成 123456789@Servicepublic class HelloService &#123; public String sayHello() &#123; return &quot;Hello&quot;; &#125; public String say(String words) &#123; return &quot;Hello &quot; + words; &#125;&#125; 4.4.2 【注解方式】示例：客户端调用服务 12345678910import org.springframework.grpc.annotation.GrpcService;/**- 使用 @GprcService 注解定义远程服务，server 指定远程服务名，必须在 application.yml 中定义才能使用 - 方法名 、参数 、 返回结果 必须与服务提供方一致 */@GrpcService(server = &quot;localhost&quot;)public interface HelloService &#123; public String sayHello(); public String say(String words);&#125; 4.4.3 【非注解方式】示例：客户端调用服务 1234567891011121314151617181920212223242526public void test() &#123; // 构建请求体 GrpcRequest grpcRequest = new GrpcRequest(); grpcRequest.setServiceBeanName(&quot;helloService&quot;); // 无参方法调用 grpcRequest.setServiceMethodName(&quot;sayHello&quot;); try &#123; // 此处服务提供方需要在配置文件中定义，否则无法调用 GrpcResponse response = GrpcClient.connect(&quot;localhost&quot;).handle(grpcRequest); if (response.getStatus() == GrpcResponseStatus.SUCCESS.getCode()) &#123; System.out.println(response.getResult()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 有参方法调用 grpcRequest.setServiceMethodName(&quot;say&quot;); Object[] args = &#123; &quot;hello&quot; &#125;; grpcRequest.setArgs(args); try &#123; // 此处服务提供方需要在配置文件中定义，否则无法调用 GrpcResponse response = GrpcClient.connect(&quot;localhost&quot;).handle(grpcRequest); if (response.getStatus() == GrpcResponseStatus.SUCCESS.getCode()) &#123; System.out.println(response.getResult()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 4.4.4 【测试使用】示例：为方便调试，通过原生方式调用远程服务，无需依赖 Spring Boot 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import com.alibaba.fastjson.JSON;import com.anoyi.rpc.CommonServiceGrpc;import com.anoyi.rpc.GrpcService;import io.grpc.ManagedChannel;import io.grpc.ManagedChannelBuilder;import org.springframework.grpc.service.GrpcRequest;import java.util.concurrent.TimeUnit;public class GrpcClient &#123; private final ManagedChannel channel; private final CommonServiceGrpc.CommonServiceBlockingStub blockingStub; public GrpcClient(String host, int port) &#123; this(ManagedChannelBuilder.forAddress(host, port).usePlaintext().build()); &#125; private GrpcClient(ManagedChannel channel) &#123; this.channel = channel; blockingStub = CommonServiceGrpc.newBlockingStub(channel); &#125; public static void main(String[] args) throws Exception &#123; GrpcClient client = new GrpcClient(&quot;localhost&quot;, 6565); try &#123; for (int i = 0; i &lt; 100; i++) &#123; String words = &quot;world - &quot; + i; client.say(words); &#125; &#125; finally &#123; client.shutdown(); &#125; &#125; private void shutdown() throws InterruptedException &#123; channel.shutdown().awaitTermination(5, TimeUnit.SECONDS); &#125; private void say(String words) &#123; GrpcRequest grpcRequest = new GrpcRequest(); grpcRequest.setBeanName(&quot;helloService&quot;); grpcRequest.setMethodName(&quot;say&quot;); Object[] params = &#123; words &#125;; grpcRequest.setArgs(params); System.out.println(&quot;远程调用 &quot; + grpcRequest.getServiceBeanName() + &quot;.&quot; + grpcRequest.getServiceMethodName() + &quot; &quot;); byte[] bytes = ProtobufUtils.serialize(grpcRequest); GrpcService.Request request = GrpcService.Request.newBuilder().setRequest(ByteString.copyFrom(bytes)).build(); GrpcService.Response response = blockingStub.handle(request); System.out.println(&quot;远程调用结果: &quot; + response.getReponse()); &#125;&#125;]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[live2d宠物安装]]></title>
    <url>%2Fmoblog.github.io%2Flive2d%2F</url>
    <content type="text"><![CDATA[Install seperated modelsuse npm install {packagename} The package name is the folder name in packages/ We have:live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install –save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install –save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以太坊 Web3.js 开发基础]]></title>
    <url>%2Fmoblog.github.io%2Fweb3-js%2F</url>
    <content type="text"><![CDATA[简介web3.js 是一个通过RPC 调用 和本地以太坊节点进行通信的js库。web3.js可以与任何暴露了RPC接口的以太坊节点连接。web3中提供了eth对象 - web3.eth来与以太坊区块链进行交互。在github上获得代码安装 Testrpc安装Ethereum客户端来支持JSON RPC API调用开发环境，推荐使用EthereumJS。安装命令：sudo npm install -g ethereumjs-testrpc 启动 testrpc在命令行执行testrpcEthereumJS TestRPC v6.0.3 (ganache-core: 2.0.2) Available Accounts(0) 0x1abb473c627e690c048dbf7a9f9cc54b25dea42a(1) 0xd50fadba656c8f78916f9c1a1b78fd3d35dad0aa(2) 0x69e0159cf8e6fc81e8e71479aea0e8984d7daf48(3) 0x5f1ebce982445a02ff4530f4d53cd09cb2a6addf(4) 0x746f6a0192cf42001ded53a55932a6dff754e143(5) 0x685dcca08e5efc905a300eff68bf2e8a81989966(6) 0x08eed3a1a801be6af543105cb9bfc27b6401c020(7) 0xc8fd99bde94fbfab654c8cffda6047b16306cc07(8) 0xc28e0b677883f809faa1eaf563a5f4b794dcbaeb(9) 0xd02b16bbaa70b2cba4ea173009f2fdf829a8ffba Private Keys(0) d233ec4635ed0fe5c61977c9442d6233c599cd3591107b9a017f7ea6077da3bc(1) a02a88b2c04aed72b55cdd6f6212e1f560dd02767f0a03627fac97b64b64086d(2) 833dd28ab15388ba162862c365313978dabb96d209c311bca7d9a7bfdb2ecb6f(3) 47c7ae2635fed1b4f5e442496fd364cdaa91ae6e950b45f36aa4ac6c172cffb5(4) 4b8ee2ee44eab299cbeff51bbf6fb74572e493409556e728a385dcf9e4dc4f84(5) 50cdb8a14babddcbb79f14ad7b5cc55e95a0b8ce72659eec1c9b8d798ff52369(6) becc6dd7a41564aaf3f2f1711eb102032ace0c4e4b561fc7c922ea92f1a81c5a(7) cc82c2ad095b32bd23e33bc9c3ef6b69ad8b76de07a9e02714760d2fd843efa5(8) 44f9c35f62ffe1aa3b85bb6e557569beb396ced7d5ab8a75345d9a8ab1283bca(9) 3d7ec84ed3253366f744a754ccdc2187d65856c2b264e9fbd651c59896aac229 HD WalletMnemonic: tilt oyster obtain car venture party power exclude fire price senior blueBase HD Path: m/44’/60’/0’/0/{account_index} Listening on localhost:8545 会自动创建10个账户，每个账户默认有100个以太币。安装和和获取web3对象安装npm: npm install web3bower: bower install web3metor: meteor add ethereum:web3vanilla: dist./web3.min.js获得web3实例if (typeof web3 !== ‘undefined’) { web3 = new Web3(web3.currentProvider);} else { // set the provider you want from Web3.providers web3 = new Web3(new Web3.providers.HttpProvider(“http://localhost:8545&quot;));} 使用实例一、账户操作：获取账户web3.eth.getAccounts(function(error, result){ res.send(result) }) 创建新账户web3.eth.accounts.create(); { address: “0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01”, privateKey: “0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709”, signTransaction: function(tx){…}, sign: function(data){…}, encrypt: function(password){…}} web3.eth.accounts.create(‘2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567’); { address: “0xF2CD2AA0c7926743B1D4310b2BC984a0a453c3d4”, privateKey: “0xd7325de5c2c1cf0009fac77d3d04a9c004b038883446b065871bc3e831dcd098”, signTransaction: function(tx){…}, sign: function(data){…}, encrypt: function(password){…}} web3.eth.accounts.create(web3.utils.randomHex(32)); { address: “0xe78150FaCD36E8EB00291e251424a0515AA1FF05”, privateKey: “0xcc505ee6067fba3f6fc2050643379e190e087aeffe5d958ab9f2f3ed3800fa4e”, signTransaction: function(tx){…}, sign: function(data){…}, encrypt: function(password){…}} 使用私钥创建账户web3.eth.accounts.privateKeyToAccount(privateKey);web3.eth.accounts.privateKeyToAccount(‘0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709’); { address: ‘0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01’, privateKey: ‘0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709’, signTransaction: function(tx){…}, sign: function(data){…}, encrypt: function(password){…}} web3.eth.accounts.privateKeyToAccount(‘0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709’); { address: ‘0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01’, privateKey: ‘0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709’, signTransaction: function(tx){…}, sign: function(data){…}, encrypt: function(password){…}} 使用私钥签名一个交易web3.eth.accounts.signTransaction(tx, privateKey [, callback]);web3.eth.accounts.signTransaction({ to: ‘0xF0109fC8DF283027b6285cc889F5aA624EaC1F55’, value: ‘1000000000’, gas: 2000000}, ‘0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318’).then(console.log); { messageHash: ‘0x88cfbd7e51c7a40540b233cf68b62ad1df3e92462f1c6018d6d67eae0f3b08f5’, v: ‘0x25’, r: ‘0xc9cf86333bcb065d140032ecaab5d9281bde80f21b9687b3e94161de42d51895’, s: ‘0x727a108a0b8d101465414033c3f705a9c7b826e596766046ee1183dbc8aeaa68’, rawTransaction: ‘0xf869808504e3b29200831e848094f0109fc8df283027b6285cc889f5aa624eac1f55843b9aca008025a0c9cf86333bcb065d140032ecaab5d9281bde80f21b9687b3e94161de42d51895a0727a108a0b8d101465414033c3f705a9c7b826e596766046ee1183dbc8aeaa68’} web3.eth.accounts.signTransaction({ to: ‘0xF0109fC8DF283027b6285cc889F5aA624EaC1F55’, value: ‘1000000000’, gas: 2000000, gasPrice: ‘234567897654321’, nonce: 0, chainId: 1}, ‘0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318’).then(console.log); { messageHash: ‘0x6893a6ee8df79b0f5d64a180cd1ef35d030f3e296a5361cf04d02ce720d32ec5’, r: ‘0x9ebb6ca057a0535d6186462bc0b465b561c94a295bdb0621fc19208ab149a9c’, s: ‘0x440ffd775ce91a833ab410777204d5341a6f9fa91216a6f3ee2c051fea6a0428’, v: ‘0x25’, rawTransaction: ‘0xf86a8086d55698372431831e848094f0109fc8df283027b6285cc889f5aa624eac1f55843b9aca008025a009ebb6ca057a0535d6186462bc0b465b561c94a295bdb0621fc19208ab149a9ca0440ffd775ce91a833ab410777204d5341a6f9fa91216a6f3ee2c051fea6a0428’} 哈希一个消息web3.eth.accounts.hashMessage(message);web3.eth.accounts.hashMessage(“Hello World”) “0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2” // the below results in the same hashweb3.eth.accounts.hashMessage(web3.utils.utf8ToHex(“Hello World”)) “0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2” sign 给任意一个内容使用私钥签名web3.eth.accounts.sign(data, privateKey);web3.eth.accounts.sign(‘Some data’, ‘0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318’); { message: ‘Some data’, messageHash: ‘0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655’, v: ‘0x1c’, r: ‘0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd’, s: ‘0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029’, signature: ‘0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c’} 使用web3.eth.personal 新建账户web3.eth.personal.newAccount(password, [callback])web3.eth.personal.newAccount(‘!@superpassword’).then(console.log); ‘0x1234567891011121314151617181920212223456’ 获得账户余额web3.eth.getBalance(‘0xe70c4835b29e2fd35bd3f60c0a76413f70f17115’).then(function(balance){ console.log(‘balance:’,balance) balance = new BigNumber(balance) console.log(‘balance:’,balance)}) 这里使用了BigNumber.js 处理余额显示，参考我另一片博文。utils工具函数web3.utils.toHex 将任何值转为HEX 16进制String|Number|Object|Array|BigNumber - 需要转化为HEX的值。如果是一个对象或数组类型，将会先用JSON.stringify1进行转换成字符串。如果传入的是BigNumber2，则将得到对应的Number的HEXvar str = “abcABC”;var obj = {abc: ‘ABC’};var bignumber = new BigNumber(‘12345678901234567890’); var hstr = web3.utils.toHex(str);var hobj = web3.utils.toHex(obj);var hbg = web3.utils.toHex(bignumber); console.log(“Hex of Sring:” + hstr);console.log(“Hex of Object:” + hobj);console.log(“Hex of BigNumber:” + hbg); web3.utils.isHex(hex) 判断输入是不是16进制web3.utils.isHex(‘0xc1912’); 判断输入是不是一个地址web3.utils.isAddress(‘0xc1912fee45d61c87cc5ea59dae31190fffff232d’); 把金额单位换成weiweb3.utils.toWei(number [, unit])web3.utils.toWei(‘1’, ‘ether’); “1000000000000000000” web3.utils.toWei(‘1’, ‘finney’); “1000000000000000” web3.utils.toWei(‘1’, ‘szabo’); “1000000000000” web3.utils.toWei(‘1’, ‘shannon’);/&gt; “1000000000” 把单位为wei的以太币换成 etherweb3.utils.fromWei(number [, unit])web3.utils.fromWei(‘1’, ‘ether’); “0.000000000000000001” web3.utils.fromWei(‘1’, ‘finney’); “0.000000000000001” web3.utils.fromWei(‘1’, ‘szabo’); “0.000000000001” web3.utils.fromWei(‘1’, ‘shannon’); “0.000000001” 判断给定的数据是否是 BigNumberweb3.utils.isBigNumber(bignumber)var number = new BigNumber(10);web3.utils.isBigNumber(number); sha3算法// web3.utils.sha3(string)// web3.utils.keccak256(string) // ALIASweb3.utils.sha3(‘234’); // taken as string “0xc1912fee45d61c87cc5ea59dae311904cd86b84fee17cc96966216f811ce6a79” web3.utils.sha3(new BN(‘234’)); “0xbc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a” web3.utils.sha3(234); null // can’t calculate the has of a number web3.utils.sha3(0xea); // same as above, just the HEX representation of the number null web3.utils.sha3(‘0xea’); // will be converted to a byte array first, and then hashed “0x2f20677459120677484f7104c76deb6846a2c071f9b3152c103bb12cd54d1a4a” [在github上获得代码] https://github.com/cooleye/web3tutorial 作者：孔德健链接：https://www.jianshu.com/p/f3f36447546e來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>web3js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next 内嵌标签demo]]></title>
    <url>%2Fmoblog.github.io%2Fmy-princess%2F</url>
    <content type="text"><![CDATA[blah blah blah blah blah blah blah blah blah 1 2 3 4 5 6 《告白气球》]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git操作命令]]></title>
    <url>%2Fmoblog.github.io%2Fgit%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git tag 给当前分支打标签原文已经找不到出处，重新整理格式，仅作个人收藏！ 标签(Tag)可以针对某一时间点的版本做标记，常用于版本发布。列出tag$ git tag # 在控制台打印出当前仓库的所有tag$ git tag -l ‘v0.1.*’ # 搜索符合模式的Tag打taggit tag分为两种类型：轻量tag和附注tag。轻量tag是指向提交对象的引用，附注Tag则是仓库中的一个独立对象。建议使用附注Tag。 创建轻量Tag$ git tag v0.1.2-light创建附注Tag$ git tag -a v0.1.2 -m “0.1.2版本”创建轻量Tag不需要传递参数，直接指定Tag名称即可。 创建附注Tag时，参数a即annotated的缩写，指定Tag类型，后附Tag名。参数m指定Tag说明，说明信息会保存在Tag对象中。 切换到Tag与切换分支命令相同，用git checkout [tagname] 查看Tag信息用git show命令可以查看Tag的版本信息： $ git show v0.1.2删除Tag误打或需要修改Tag时，需要先将Tag删除，再打新Tag。 $ git tag -d v0.1.2 # 删除Tag参数d即delete的缩写，意为删除其后指定的Tag。 给指定的commit打Tag打Tag不必要在head之上，也可在之前的版本上打，这需要你知道某个提交对象的校验和（通过git log获取）。 补打Tag $ git tag -a v0.1.1 9fbc3d0Tag推送到服务器通常的git push不会将Tag对象提交到git服务器，我们需要进行显式的操作： $ git push origin v0.1.2 # 将v0.1.2 Tag提交到git服务器$ git push origin –-tags # 将本地所有Tag一次性提交到git服务器注意：如果想看之前某个Tag状态下的文件，可以这样操作 1.git tag 查看当前分支下的Tag 2.git checkout v0.21 此时会指向打v0.21 Tag时的代码状态，（但现在处于一个空的分支上） cat test.txt 查看某个文件]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 命令]]></title>
    <url>%2Fmoblog.github.io%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment #hh]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
